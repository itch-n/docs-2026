<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A framework for algorithms, systems design, and infrastructure.">
    <meta name="author" content="Richard">
    
    <link rel="shortcut icon" href="../../img/favicon.ico">

    
    <title>04. Search & Indexing - Software Engineering Study Guide</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css">
        
    
    <link href="../../css/custom.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="../..">Software Engineering Study Guide</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Systems Design <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../01-storage-engines/">01. Storage Engines</a>
</li>

                        
                            
<li >
    <a href="../02-row-vs-column-storage/">02. Row vs Column Storage</a>
</li>

                        
                            
<li >
    <a href="../03-networking-fundamentals/">03. Networking Fundamentals</a>
</li>

                        
                            
<li class="active">
    <a href="./">04. Search & Indexing</a>
</li>

                        
                            
<li >
    <a href="../05-caching-patterns/">05. Caching Patterns</a>
</li>

                        
                            
<li >
    <a href="../06-api-design/">06. API Design</a>
</li>

                        
                            
<li >
    <a href="../07-security-patterns/">07. Security Patterns</a>
</li>

                        
                            
<li >
    <a href="../08-rate-limiting/">08. Rate Limiting</a>
</li>

                        
                            
<li >
    <a href="../09-load-balancing/">09. Load Balancing</a>
</li>

                        
                            
<li >
    <a href="../10-concurrency-patterns/">10. Concurrency Patterns</a>
</li>

                        
                            
<li >
    <a href="../11-database-scaling/">11. Database Scaling</a>
</li>

                        
                            
<li >
    <a href="../12-message-queues/">12. Message Queues</a>
</li>

                        
                            
<li >
    <a href="../13-stream-processing/">13. Stream Processing</a>
</li>

                        
                            
<li >
    <a href="../14-observability/">14. Observability</a>
</li>

                        
                            
<li >
    <a href="../15-distributed-transactions/">15. Distributed Transactions</a>
</li>

                        
                            
<li >
    <a href="../16-consensus-patterns/">16. Consensus Patterns</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">DSA <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../dsa/01-two-pointers/">01. Two Pointers</a>
</li>

                        
                            
<li >
    <a href="../../dsa/02-sliding-window/">02. Sliding Window</a>
</li>

                        
                            
<li >
    <a href="../../dsa/03-hash-tables/">03. Hash Tables</a>
</li>

                        
                            
<li >
    <a href="../../dsa/04-linked-lists/">04. Linked Lists</a>
</li>

                        
                            
<li >
    <a href="../../dsa/05-stacks--queues/">05. Stacks & Queues</a>
</li>

                        
                            
<li >
    <a href="../../dsa/06-trees-traversals/">06. Trees - Traversals</a>
</li>

                        
                            
<li >
    <a href="../../dsa/07-trees-recursion/">07. Trees - Recursion</a>
</li>

                        
                            
<li >
    <a href="../../dsa/08-binary-search/">08. Binary Search</a>
</li>

                        
                            
<li >
    <a href="../../dsa/09-heaps/">09. Heaps</a>
</li>

                        
                            
<li >
    <a href="../../dsa/10-graphs/">10. Graphs</a>
</li>

                        
                            
<li >
    <a href="../../dsa/11-union-find/">11. Union-Find</a>
</li>

                        
                            
<li >
    <a href="../../dsa/12-advanced-graphs/">12. Advanced Graphs</a>
</li>

                        
                            
<li >
    <a href="../../dsa/13-backtracking/">13. Backtracking</a>
</li>

                        
                            
<li >
    <a href="../../dsa/14-dynamic-programming-1d/">14. Dynamic Programming 1D</a>
</li>

                        
                            
<li >
    <a href="../../dsa/15-dynamic-programming-2d/">15. Dynamic Programming 2D</a>
</li>

                        
                            
<li >
    <a href="../../dsa/16-tries/">16. Tries</a>
</li>

                        
                            
<li >
    <a href="../../dsa/17-advanced-topics/">17. Advanced Topics</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../03-networking-fundamentals/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../05-caching-patterns/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#search-indexing">Search &amp; Indexing</a></li>
            <li class="second-level"><a href="#eli5-explain-like-im-5">ELI5: Explain Like I'm 5</a></li>
                
            <li class="second-level"><a href="#quick-quiz-do-before-learning">Quick Quiz (Do BEFORE learning)</a></li>
                
            <li class="second-level"><a href="#beforeafter-why-search-indexing-matters">Before/After: Why Search Indexing Matters</a></li>
                
            <li class="second-level"><a href="#case-studies-search-indexing-in-the-wild">Case Studies: Search &amp; Indexing in the Wild</a></li>
                
            <li class="second-level"><a href="#core-concepts">Core Concepts</a></li>
                
            <li class="second-level"><a href="#decision-framework">Decision Framework</a></li>
                
            <li class="second-level"><a href="#practice-scenarios">Practice Scenarios</a></li>
                
            <li class="second-level"><a href="#review-checklist">Review Checklist</a></li>
                
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="search-indexing">Search &amp; Indexing<a class="headerlink" href="#search-indexing" title="Permanent link">&para;</a></h1>
<blockquote>
<p>Inverted indexes, full-text search, ranking algorithms, and distributed search systems</p>
</blockquote>
<hr />
<h2 id="eli5-explain-like-im-5">ELI5: Explain Like I'm 5<a class="headerlink" href="#eli5-explain-like-im-5" title="Permanent link">&para;</a></h2>
<div class="learner-section">
<p><strong>Your task:</strong> After learning search and indexing, explain them simply.</p>
<p><strong>Prompts to guide you:</strong></p>
<ol>
<li>
<p><strong>What is an inverted index in one sentence?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
</li>
<li>
<p><strong>Why can't we just search through all documents linearly?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
</li>
<li>
<p><strong>Real-world analogy for inverted index:</strong></p>
<ul>
<li>Example: "An inverted index is like a book's index where..."</li>
<li>Your analogy: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li>
<p><strong>What makes search results "relevant"?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
</li>
<li>
<p><strong>Real-world analogy for search ranking:</strong></p>
<ul>
<li>Example: "TF-IDF is like voting where..."</li>
<li>Your analogy: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li>
<p><strong>Why do we need sharding for search?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after practice]</span></li>
</ul>
</li>
</ol>
</div>
<hr />
<h2 id="quick-quiz-do-before-learning">Quick Quiz (Do BEFORE learning)<a class="headerlink" href="#quick-quiz-do-before-learning" title="Permanent link">&para;</a></h2>
<div class="learner-section">
<p><strong>Your task:</strong> Test your intuition about search without looking at details. Answer these, then verify after learning.</p>
<h3 id="complexity-predictions">Complexity Predictions<a class="headerlink" href="#complexity-predictions" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>Linear search through 1M documents:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Estimated time: <span class="fill-in">[Milliseconds? Seconds?]</span></li>
<li>Verified: <span class="fill-in">[Actual]</span></li>
</ul>
</li>
<li>
<p><strong>Inverted index lookup:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Space overhead: <span class="fill-in">[How much extra storage?]</span></li>
<li>Verified: <span class="fill-in">[Actual]</span></li>
</ul>
</li>
<li>
<p><strong>Autocomplete suggestions with trie:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Space complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Verified: <span class="fill-in">[Actual]</span></li>
</ul>
</li>
</ol>
<h3 id="scenario-predictions">Scenario Predictions<a class="headerlink" href="#scenario-predictions" title="Permanent link">&para;</a></h3>
<p><strong>Scenario 1:</strong> Search query "machine learning" in 10M documents</p>
<ul>
<li><strong>Without index:</strong> <span class="fill-in">[How long?]</span></li>
<li><strong>With inverted index:</strong> <span class="fill-in">[How long?]</span></li>
<li><strong>Speedup factor:</strong> <span class="fill-in">[____x faster?]</span></li>
</ul>
<p><strong>Scenario 2:</strong> E-commerce product search with typos</p>
<ul>
<li><strong>Exact match only:</strong> <span class="fill-in">[User experience?]</span></li>
<li><strong>Fuzzy search:</strong> <span class="fill-in">[How to implement?]</span></li>
<li><strong>Trade-off:</strong> <span class="fill-in">[Performance vs accuracy?]</span></li>
</ul>
<p><strong>Scenario 3:</strong> Ranking search results by relevance</p>
<ul>
<li><strong>Algorithm:</strong> <span class="fill-in">[TF-IDF? BM25? Something else?]</span></li>
<li><strong>Factors to consider:</strong> <span class="fill-in">[What matters?]</span></li>
<li><strong>Personalization:</strong> <span class="fill-in">[How to incorporate?]</span></li>
</ul>
</div>
<hr />
<h2 id="beforeafter-why-search-indexing-matters">Before/After: Why Search Indexing Matters<a class="headerlink" href="#beforeafter-why-search-indexing-matters" title="Permanent link">&para;</a></h2>
<p><strong>Your task:</strong> Compare naive search vs indexed search to understand the impact.</p>
<h3 id="example-product-search-on-e-commerce-site">Example: Product Search on E-Commerce Site<a class="headerlink" href="#example-product-search-on-e-commerce-site" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Search for "wireless headphones" across 10 million products</p>
<h4 id="approach-1-naive-linear-search">Approach 1: Naive Linear Search<a class="headerlink" href="#approach-1-naive-linear-search" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-sql">SELECT * FROM products
WHERE
  LOWER(name) LIKE '%wireless%'
  AND LOWER(name) LIKE '%headphones%'
OR
  LOWER(description) LIKE '%wireless%'
  AND LOWER(description) LIKE '%headphones%';</code></pre>
<p><strong>What happens:</strong>
<pre class="highlight"><code>Database scans all 10M rows:
Row 1: Check name, check description → No match
Row 2: Check name, check description → No match
...
Row 45,234: Check name → MATCH! (add to results)
...
Row 10,000,000: Check name, check description → No match

Time: ~10-30 seconds
Database CPU: 100%
User experience: Loading spinner... user leaves</code></pre></p>
<p><strong>Problems:</strong></p>
<ul>
<li>O(N × M) where N = documents, M = avg document size</li>
<li>No ranking (random order)</li>
<li>No fuzzy matching ("wireles" returns nothing)</li>
<li>Kills database under load</li>
</ul>
<h4 id="approach-2-inverted-index-search">Approach 2: Inverted Index Search<a class="headerlink" href="#approach-2-inverted-index-search" title="Permanent link">&para;</a></h4>
<p><strong>Index structure:</strong>
<pre class="highlight"><code>Inverted Index:
"wireless" → [doc45234, doc89123, doc234556, ...]
"headphones" → [doc12345, doc45234, doc67890, ...]

Intersection: [doc45234] ← Both terms present

Ranking (TF-IDF):
doc45234: score = 8.7 (both in title, high frequency)
doc89123: score = 6.2 (both in description)
doc12345: score = 4.1 (only "headphones" in title)</code></pre></p>
<p><strong>Query execution:</strong>
<pre class="highlight"><code>
1. Look up "wireless" → [45234, 89123, 234556, ...] (1ms)
2. Look up "headphones" → [12345, 45234, 67890, ...] (1ms)
3. Intersect lists → [45234, ...] (5ms)
4. Rank by score → sorted results (10ms)
5. Return top 20 results (1ms)

Total: ~20ms
Database CPU: 5%
User experience: Instant results ✓</code></pre></p>
<p><strong>Performance comparison:</strong></p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Linear Search</th>
<th>Inverted Index</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time</td>
<td>10-30s</td>
<td>20ms</td>
<td>500-1500x faster</td>
</tr>
<tr>
<td>CPU usage</td>
<td>100%</td>
<td>5%</td>
<td>20x less</td>
</tr>
<tr>
<td>Scalability</td>
<td>O(N)</td>
<td>O(log N)</td>
<td>Sublinear</td>
</tr>
<tr>
<td>Ranking</td>
<td>No</td>
<td>Yes (TF-IDF)</td>
<td>Better UX</td>
</tr>
<tr>
<td>Fuzzy match</td>
<td>Hard</td>
<td>Easy</td>
<td>More results</td>
</tr>
</tbody>
</table>
<p><strong>Real-world impact:</strong></p>
<ul>
<li>Without indexing: 80% bounce rate (users leave)</li>
<li>With indexing: 5% bounce rate, 10x more conversions</li>
<li>Cost: $100K/month in extra servers vs $10K/month with proper indexing</li>
</ul>
<p><strong>Your calculation:</strong> For 100M documents:</p>
<ul>
<li>Linear search time: <span class="fill-in">_____</span> seconds</li>
<li>Indexed search time: <span class="fill-in">_____</span> ms</li>
<li>Users served per second: Linear <span class="fill-in"><strong><em>_</em></span> vs Indexed <span class="fill-in"></strong>___</span></li>
</ul>
<hr />
<h2 id="case-studies-search-indexing-in-the-wild">Case Studies: Search &amp; Indexing in the Wild<a class="headerlink" href="#case-studies-search-indexing-in-the-wild" title="Permanent link">&para;</a></h2>
<h3 id="google-search-pagerank-and-the-inverted-index">Google Search: PageRank and the Inverted Index<a class="headerlink" href="#google-search-pagerank-and-the-inverted-index" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Pattern:</strong> Distributed Inverted Index combined with the PageRank ranking algorithm.</li>
<li><strong>How it works:</strong> Google's crawlers build a massive inverted index of the web. When you search, your query terms are
  used to retrieve a list of matching documents. The magic is in the ranking: PageRank analyzes the web's link
  structure, treating a link from page A to page B as a "vote" for page B. It ranks pages higher if they are linked to
  by many other high-ranking pages.</li>
<li><strong>Key Takeaway:</strong> A fast inverted index is only half the battle. The relevance of search results is determined by
  sophisticated ranking algorithms. PageRank revolutionized search by using the collective intelligence of the web
  itself to determine authority and importance.</li>
</ul>
<h3 id="elasticsearch-powering-enterprise-search">Elasticsearch: Powering Enterprise Search<a class="headerlink" href="#elasticsearch-powering-enterprise-search" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Pattern:</strong> Distributed, Sharded Inverted Index (using Apache Lucene).</li>
<li><strong>How it works:</strong> Companies like <strong>Uber</strong> (for searching trips), <strong>Stack Overflow</strong> (for finding questions), and *
  <em>Netflix</em><em> (for catalog search) use Elasticsearch. It automatically builds an inverted index on JSON documents. To
  scale, it partitions the index into multiple </em><em>shards</em>*, and replicates them for fault tolerance. A query is sent to
  all shards in parallel, and the results are aggregated by a coordinating node.</li>
<li><strong>Key Takeaway:</strong> Elasticsearch democratized high-quality search. It packages the complex concepts of inverted
  indexes, text analysis, and distributed systems into a scalable, easy-to-use product, making it the de-facto standard
  for adding search capabilities to applications.</li>
</ul>
<h3 id="algolia-search-as-a-service-for-speed">Algolia: Search-as-a-Service for Speed<a class="headerlink" href="#algolia-search-as-a-service-for-speed" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Pattern:</strong> In-Memory, Prefix-based Trie/Index Hybrid.</li>
<li><strong>How it works:</strong> Algolia is designed for "instant search" and autocomplete experiences. They store their indices
  entirely in RAM and distribute them across multiple data centers for low latency. Their ranking is often based on a
  tie-breaking algorithm that can be heavily customized with business metrics (e.g., for an e-commerce site, rank
  products with more sales higher).</li>
<li><strong>Key Takeaway:</strong> For user-facing search where speed is paramount, in-memory indices and pre-computed ranking can
  provide a superior user experience. The trade-off is higher cost and a focus on prefix-matching rather than complex
  full-text relevance ranking.</li>
</ul>
<hr />
<h2 id="core-concepts">Core Concepts<a class="headerlink" href="#core-concepts" title="Permanent link">&para;</a></h2>
<h3 id="topic-1-inverted-index">Topic 1: Inverted Index<a class="headerlink" href="#topic-1-inverted-index" title="Permanent link">&para;</a></h3>
<p><strong>Concept:</strong> Data structure that maps terms to documents, enabling fast full-text search.</p>
<p><strong>How It Works:</strong></p>
<p><strong>Forward Index (Document → Terms):</strong>
<pre class="highlight"><code>doc1: "the quick brown fox"
doc2: "the lazy dog"
doc3: "quick brown dog"

Not efficient for search!
To find "quick", must scan all documents.</code></pre></p>
<p><strong>Inverted Index (Term → Documents):</strong>
<pre class="highlight"><code>"the"     → [doc1, doc2]
"quick"   → [doc1, doc3]
"brown"   → [doc1, doc3]
"fox"     → [doc1]
"lazy"    → [doc2]
"dog"     → [doc2, doc3]

Search "quick" → O(1) lookup → [doc1, doc3]</code></pre></p>
<p><strong>With Positional Information:</strong>
<pre class="highlight"><code>"quick" → [
  doc1: [positions: 1],
  doc3: [positions: 0]
]

"brown" → [
  doc1: [positions: 2],
  doc3: [positions: 1]
]

Phrase search "quick brown":

- Find docs with both terms
- Check if positions are adjacent
- doc1: positions 1,2 → ✓ Match!
- doc3: positions 0,1 → ✓ Match!</code></pre></p>
<p><strong>Building an Inverted Index:</strong></p>
<pre class="highlight"><code>Input documents:
doc1: "Machine Learning Basics"
doc2: "Deep Learning with Python"
doc3: "Machine Learning Algorithms"

Step 1: Tokenization
doc1: ["machine", "learning", "basics"]
doc2: ["deep", "learning", "with", "python"]
doc3: ["machine", "learning", "algorithms"]

Step 2: Normalization (lowercase, stemming)
doc1: ["machin", "learn", "basic"]
doc2: ["deep", "learn", "with", "python"]
doc3: ["machin", "learn", "algorithm"]

Step 3: Build index
{
  "machin":    [doc1, doc3],
  "learn":     [doc1, doc2, doc3],
  "basic":     [doc1],
  "deep":      [doc2],
  "with":      [doc2],
  "python":    [doc2],
  "algorithm": [doc3]
}

Step 4: Add term frequencies (TF)
{
  "learn": [
    {doc: doc1, tf: 1, positions: [1]},
    {doc: doc2, tf: 1, positions: [1]},
    {doc: doc3, tf: 1, positions: [1]}
  ]
}</code></pre>
<p><strong>Inverted Index Data Structure (Simplified):</strong></p>
<pre class="highlight"><code class="language-java">class InvertedIndex {
    // Term → Posting List
    Map&lt;String, PostingList&gt; index;

    class PostingList {
        List&lt;Posting&gt; postings;
        int documentFrequency; // How many docs contain this term
    }

    class Posting {
        int documentId;
        int termFrequency;     // How many times in this doc
        List&lt;Integer&gt; positions; // Where in doc
    }

    // Search for term
    PostingList search(String term) {
        return index.get(normalize(term));
    }

    // Boolean AND query: term1 AND term2
    List&lt;Integer&gt; intersect(String term1, String term2) {
        PostingList p1 = search(term1);
        PostingList p2 = search(term2);

        // Merge postings lists (efficient with sorted lists)
        return mergeSortedLists(p1, p2);
    }
}</code></pre>
<p><strong>Time Complexity:</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single term lookup</td>
<td>O(1) or O(log V)</td>
<td>V = vocabulary size</td>
</tr>
<tr>
<td>Boolean AND (2 terms)</td>
<td>O(n₁ + n₂)</td>
<td>n = posting list sizes</td>
</tr>
<tr>
<td>Boolean OR</td>
<td>O(n₁ + n₂)</td>
<td>Merge lists</td>
</tr>
<tr>
<td>Phrase query</td>
<td>O(n × k)</td>
<td>k = terms in phrase</td>
</tr>
<tr>
<td>Index construction</td>
<td>O(N × M)</td>
<td>N = docs, M = avg size</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="topic-2-text-analysis-tokenization">Topic 2: Text Analysis &amp; Tokenization<a class="headerlink" href="#topic-2-text-analysis-tokenization" title="Permanent link">&para;</a></h3>
<p><strong>Concept:</strong> Process of converting raw text into searchable terms.</p>
<p><strong>Text Analysis Pipeline:</strong></p>
<pre class="highlight"><code>Input: "The Quick Brown Fox's 2024 Adventure!"

Step 1: Character Filtering
→ "The Quick Brown Fox's 2024 Adventure"
(Remove special characters)

Step 2: Tokenization
→ ["The", "Quick", "Brown", "Fox's", "2024", "Adventure"]
(Split into words)

Step 3: Lowercase Filter
→ ["the", "quick", "brown", "fox's", "2024", "adventure"]

Step 4: Stop Word Removal (optional)
→ ["quick", "brown", "fox's", "2024", "adventure"]
(Remove "the")

Step 5: Stemming/Lemmatization
→ ["quick", "brown", "fox", "2024", "adventur"]
(fox's → fox, adventure → adventur)

Step 6: N-gram Generation (optional)
→ ["quick", "brown", "fox", "quick brown", "brown fox"]</code></pre>
<p><strong>Tokenization Strategies:</strong></p>
<p><strong>Word-based tokenization:</strong>
<pre class="highlight"><code>Input: "I'm learning Elasticsearch 8.0!"

Whitespace tokenizer:
→ ["I'm", "learning", "Elasticsearch", "8.0!"]

Standard tokenizer (Unicode-aware):
→ ["I'm", "learning", "Elasticsearch", "8", "0"]

Letter tokenizer (only letters):
→ ["I", "m", "learning", "Elasticsearch"]</code></pre></p>
<p><strong>N-gram tokenization (for autocomplete, fuzzy search):</strong>
<pre class="highlight"><code>Input: "search"

Unigrams: ["s", "e", "a", "r", "c", "h"]
Bigrams: ["se", "ea", "ar", "rc", "ch"]
Trigrams: ["sea", "ear", "arc", "rch"]

Use case: Fuzzy search
Query "serch" (typo):

- Trigrams: ["ser", "erc", "rch"]
- "search" trigrams: ["sea", "ear", "arc", "rch"]
- Overlap: ["erc", "rch"] → Possible match!</code></pre></p>
<p><strong>Stemming vs Lemmatization:</strong></p>
<pre class="highlight"><code>Stemming (rule-based, faster, less accurate):
running → run
runs → run
runner → runner (different stem!)
better → better (no change)

Lemmatization (dictionary-based, slower, accurate):
running → run
runs → run
runner → runner
better → good (finds lemma!)

Trade-off:
Stemming: Fast, simple, handles unknown words
Lemmatization: Accurate, context-aware, slower</code></pre>
<hr />
<h3 id="topic-3-ranking-algorithms">Topic 3: Ranking Algorithms<a class="headerlink" href="#topic-3-ranking-algorithms" title="Permanent link">&para;</a></h3>
<p><strong>Concept:</strong> Algorithms to score and rank search results by relevance.</p>
<p><strong>TF-IDF (Term Frequency-Inverse Document Frequency):</strong></p>
<p><strong>Formula:</strong>
<pre class="highlight"><code>TF-IDF(term, doc) = TF(term, doc) × IDF(term)

TF(term, doc) = (count of term in doc) / (total terms in doc)

IDF(term) = log(total documents / documents containing term)</code></pre></p>
<p><strong>Example:</strong></p>
<pre class="highlight"><code>Documents:
doc1: "cat dog cat"
doc2: "dog bird"
doc3: "cat bird fish"
doc4: "fish"

Query: "cat dog"

For "cat" in doc1:
TF = 2/3 = 0.67 (appears 2 times in 3 words)
IDF = log(4/2) = log(2) = 0.30 (in 2 out of 4 docs)
TF-IDF = 0.67 × 0.30 = 0.20

For "dog" in doc1:
TF = 1/3 = 0.33
IDF = log(4/2) = 0.30
TF-IDF = 0.33 × 0.30 = 0.10

doc1 score = 0.20 + 0.10 = 0.30
doc2 score = [calculate similarly]
doc3 score = [calculate similarly]

Ranked results:

1. doc1 (0.30) ← Both terms, high frequency
2. doc2 (0.15) ← Has "dog" only
3. doc3 (0.10) ← Has "cat" only</code></pre>
<p><strong>BM25 (Best Match 25) - Modern Improvement:</strong></p>
<pre class="highlight"><code>BM25 advantages over TF-IDF:

1. Diminishing returns for term frequency
   (10 occurrences not 10x better than 1)
2. Document length normalization
   (Shorter docs don't get unfair advantage)
3. Tunable parameters (k₁, b)

Formula (simplified):
score = IDF × (TF × (k₁ + 1)) / (TF + k₁ × (1 - b + b × docLen/avgDocLen))

Where:
k₁ = term frequency saturation (default: 1.2)
b = length normalization (default: 0.75)</code></pre>
<p><strong>Practical Example (Elasticsearch):</strong></p>
<pre class="highlight"><code class="language-json">Query: "machine learning tutorial"

BM25 scoring:
doc1: "Machine Learning Tutorial for Beginners"
  - All 3 terms present ✓
  - Terms in title (boosted) ✓
  - Short document ✓
  Score: 12.5

doc2: "Introduction to Machine Learning: A Complete Tutorial Guide..."
  - All 3 terms present ✓
  - "machine learning" together (phrase bonus) ✓
  - Long document ✗
  Score: 10.2

doc3: "Python Tutorial"
  - 1 term present ("tutorial")
  - Common term (lower IDF) ✗
  Score: 2.1

Ranking: doc1 &gt; doc2 &gt; doc3</code></pre>
<p><strong>Field Boosting:</strong></p>
<pre class="highlight"><code class="language-json">{
  "query": {
    "multi_match": {
      "query": "elasticsearch",
      "fields": [
        "title^3",        // 3x weight
        "category^2",     // 2x weight
        "content^1"       // 1x weight (default)
      ]
    }
  }
}

Effect:
Match in title = 3x more important than content
Prioritizes documents with query terms in prominent fields</code></pre>
<hr />
<h3 id="topic-4-advanced-search-features">Topic 4: Advanced Search Features<a class="headerlink" href="#topic-4-advanced-search-features" title="Permanent link">&para;</a></h3>
<p><strong>Concept:</strong> Techniques for fuzzy matching, autocomplete, and query optimization.</p>
<p><strong>Fuzzy Search (Edit Distance):</strong></p>
<pre class="highlight"><code>Levenshtein Distance: minimum edits to transform one string into another

Example: "quick" → "quik"
Operations:

1. Delete 'c' → "quik"
Distance = 1

Query: "elasticsarch" (typo)
Fuzzy search with distance 2:

- "elasticsearch" (distance 1: insert 'e')
- "elasticcache" (too far, distance 3)

Implementation:
query: {
  "fuzzy": {
    "name": {
      "value": "elasticsarch",
      "fuzziness": "AUTO"  // 0,1,2 based on term length
    }
  }
}</code></pre>
<p><strong>Autocomplete with Tries:</strong></p>
<pre class="highlight"><code>Trie structure for autocomplete:
         root
        /   \
       s     c
      / \     \
     e   t     a
    /     \     \
   a       o     t
  /         \
 r           p
/
c
h

Words: "search", "stop", "cat"

Autocomplete "se":

1. Traverse: root → s → e
2. Find all descendants: "search"
3. Return top 10 by frequency

Time: O(k) where k = prefix length
Space: O(N × M) where N = words, M = avg length</code></pre>
<p><strong>Autocomplete with Edge N-grams:</strong></p>
<pre class="highlight"><code>Term: "search"

Edge n-grams (prefix-based):
s
se
sea
sear
searc
search

Index these as tokens:
"s" → [search, ...]
"se" → [search, set, ...]
"sea" → [search, season, ...]

Query "sea":
→ Instant lookup → [search, season, ...]

Advantage: O(1) lookup vs Trie traversal
Disadvantage: Higher storage cost</code></pre>
<p><strong>Highlighting:</strong></p>
<pre class="highlight"><code>Query: "machine learning"
Result: "Introduction to Machine Learning algorithms..."

Highlighted:
"Introduction to &lt;em&gt;Machine&lt;/em&gt; &lt;em&gt;Learning&lt;/em&gt; algorithms..."

Implementation:

1. Find term positions from inverted index
2. Extract surrounding context (±50 chars)
3. Insert highlight tags
4. Return fragments

Advanced: Multi-field highlighting
Show snippets from title, description, and content
Rank snippets by relevance</code></pre>
<hr />
<h3 id="topic-5-distributed-search-elasticsearch-architecture">Topic 5: Distributed Search (Elasticsearch Architecture)<a class="headerlink" href="#topic-5-distributed-search-elasticsearch-architecture" title="Permanent link">&para;</a></h3>
<p><strong>Concept:</strong> Scale search across multiple nodes for performance and reliability.</p>
<p><strong>Sharding:</strong></p>
<pre class="highlight"><code>Index: 10M documents
Shard into 5 primary shards:

Shard 0: docs 0-2M
Shard 1: docs 2M-4M
Shard 2: docs 4M-6M
Shard 3: docs 6M-8M
Shard 4: docs 8M-10M

Query execution:

1. Send query to all 5 shards (parallel)
2. Each shard searches its 2M docs
3. Return top 10 from each shard
4. Coordinator merges 50 results
5. Return final top 10

Time: O(N/S) where S = shards
Parallelization: 5x faster (ideal)</code></pre>
<p><strong>Replication:</strong></p>
<pre class="highlight"><code>Cluster: 3 nodes
Index: 2 primary shards, 1 replica

Distribution:
Node 1: Primary 0, Replica 1
Node 2: Primary 1, Replica 0
Node 3: Replica 0, Replica 1

Availability:

- Node 1 fails → Node 2 has Primary 1 and Replica 0
- All data still accessible
- Automatic promotion of replicas

Performance:

- Reads can use replicas (load balancing)
- Writes go to primary, then replicated</code></pre>
<p><strong>Query Execution Flow:</strong></p>
<pre class="highlight"><code>Client → Load Balancer → Coordinating Node

Coordinating Node:

1. Parse query
2. Determine target shards
3. Broadcast to all shards
4. Collect results
5. Merge and rank
6. Return to client

           Coordinator
          /     |     \
     Shard0  Shard1  Shard2
       ↓       ↓       ↓
     [10]    [10]    [10]  ← Top 10 from each
       \       |      /
         Merge &amp; Sort
              ↓
         Final Top 10</code></pre>
<p><strong>Routing:</strong></p>
<pre class="highlight"><code>Document ID → Shard assignment

Hash-based routing:
shard = hash(document_id) % num_shards

Custom routing (co-locate related docs):
PUT /users/_doc/user123?routing=tenant_A
→ All tenant_A docs in same shard
→ Faster tenant-scoped queries

Trade-off:

- Better locality
- Risk of unbalanced shards</code></pre>
<hr />
<h3 id="topic-6-search-optimization">Topic 6: Search Optimization<a class="headerlink" href="#topic-6-search-optimization" title="Permanent link">&para;</a></h3>
<p><strong>Concept:</strong> Techniques to improve search performance and relevance.</p>
<p><strong>Index-Time Optimizations:</strong></p>
<p><strong>1. Selective Indexing:</strong>
<pre class="highlight"><code class="language-json">{
  "mappings": {
    "properties": {
      "id": {
        "type": "keyword",
        "index": false  // Don't index, only store
      },
      "title": {
        "type": "text",
        "analyzer": "english"  // Full-text search
      },
      "created_at": {
        "type": "date",
        "index": true  // For filtering/sorting
      }
    }
  }
}

Effect:

- Smaller index size
- Faster indexing
- Reduced memory usage</code></pre></p>
<p><strong>2. Doc Values (Column Store):</strong>
<pre class="highlight"><code>Traditional (row-oriented):
doc1: {name: "Alice", age: 30, city: "NYC"}
doc2: {name: "Bob", age: 25, city: "LA"}

Doc values (column-oriented):
name: ["Alice", "Bob"]
age: [30, 25]
city: ["NYC", "LA"]

Use case: Aggregations, sorting
Query: "Average age by city"
→ Scan age and city columns only
→ Much faster than loading full docs</code></pre></p>
<p><strong>Query-Time Optimizations:</strong></p>
<p><strong>1. Filter Context vs Query Context:</strong>
<pre class="highlight"><code class="language-json">// Query context (scored):
{
  "query": {
    "match": {
      "content": "elasticsearch"  // Score by relevance
    }
  }
}

// Filter context (not scored, cacheable):
{
  "query": {
    "bool": {
      "must": {
        "match": { "content": "elasticsearch" }
      },
      "filter": {
        "term": { "status": "published" }  // Binary: yes/no
      }
    }
  }
}

Filter benefits:

+ Cached (reused across queries)
+ Faster (no scoring)
+ Use for: dates, categories, flags</code></pre></p>
<p><strong>2. Query Caching:</strong>
<pre class="highlight"><code>Request cache (entire query result):
{
  "size": 0,  // Only aggregations, no docs
  "aggs": { ... }
}
→ Cached for 1 minute
→ Subsequent identical queries instant

Shard request cache:

- Caches query results per shard
- Invalidated on shard changes
- Shared across all queries hitting shard</code></pre></p>
<p><strong>3. Pagination:</strong>
<pre class="highlight"><code>Deep pagination problem:
GET /products?from=10000&amp;size=10

Process:

1. Each shard returns top 10,010 results
2. Coordinator merges (5 shards × 10,010 = 50,050 docs)
3. Sorts all 50,050
4. Returns results 10,000-10,010

Memory intensive! CPU intensive!

Solution 1: Search After (cursor-based)
GET /products?search_after=[value]
→ Continue from last result
→ No offset limit

Solution 2: Scroll API (for exports)
GET /products?scroll=1m
→ Snapshot of results
→ Iterate through batches</code></pre></p>
<hr />
<h2 id="decision-framework">Decision Framework<a class="headerlink" href="#decision-framework" title="Permanent link">&para;</a></h2>
<h3 id="question-1-when-to-build-inverted-index">Question 1: When to build inverted index?<a class="headerlink" href="#question-1-when-to-build-inverted-index" title="Permanent link">&para;</a></h3>
<p><strong>Build inverted index when:</strong></p>
<ul>
<li>Full-text search required: <span class="fill-in">[Search within documents]</span></li>
<li>Fast lookups critical: <span class="fill-in">[&lt; 100ms query time]</span></li>
<li>Dataset size &gt; 10K docs: <span class="fill-in">[Linear search too slow]</span></li>
</ul>
<p><strong>Skip inverted index when:</strong></p>
<ul>
<li>Exact key lookups only: <span class="fill-in">[Use hash table]</span></li>
<li>Tiny dataset (&lt; 1K docs): <span class="fill-in">[Linear scan acceptable]</span></li>
<li>Write-heavy, rare reads: <span class="fill-in">[Index overhead not worth it]</span></li>
</ul>
<h3 id="question-2-tf-idf-vs-bm25">Question 2: TF-IDF vs BM25?<a class="headerlink" href="#question-2-tf-idf-vs-bm25" title="Permanent link">&para;</a></h3>
<p><strong>Use TF-IDF when:</strong></p>
<ul>
<li>Simple implementation needed</li>
<li>Legacy system compatibility</li>
<li>Small datasets</li>
</ul>
<p><strong>Use BM25 when:</strong></p>
<ul>
<li>Production search system</li>
<li>Varied document lengths</li>
<li>Better ranking required (modern default)</li>
</ul>
<h3 id="question-3-sharding-strategy">Question 3: Sharding strategy?<a class="headerlink" href="#question-3-sharding-strategy" title="Permanent link">&para;</a></h3>
<p><strong>Use hash-based sharding when:</strong></p>
<ul>
<li>Uniform distribution desired</li>
<li>No co-location requirements</li>
<li>Simple setup</li>
</ul>
<p><strong>Use custom routing when:</strong></p>
<ul>
<li>Multi-tenancy (tenant per shard)</li>
<li>Co-locate related documents</li>
<li>Optimize specific query patterns</li>
</ul>
<hr />
<h2 id="practice-scenarios">Practice Scenarios<a class="headerlink" href="#practice-scenarios" title="Permanent link">&para;</a></h2>
<h3 id="scenario-1-e-commerce-product-search">Scenario 1: E-Commerce Product Search<a class="headerlink" href="#scenario-1-e-commerce-product-search" title="Permanent link">&para;</a></h3>
<p><strong>Requirements:</strong></p>
<ul>
<li>10M products</li>
<li>Autocomplete (&lt; 50ms)</li>
<li>Fuzzy matching for typos</li>
<li>Category filters</li>
<li>Price range filters</li>
<li>Rank by relevance + popularity</li>
</ul>
<p><strong>Your design:</strong></p>
<p>Index structure:</p>
<ul>
<li>Shards: <span class="fill-in">[How many?]</span></li>
<li>Replicas: <span class="fill-in">[How many for HA?]</span></li>
<li>Mapping: <span class="fill-in">[Which fields indexed?]</span></li>
</ul>
<p>Query strategy:</p>
<ul>
<li>Autocomplete: <span class="fill-in">[Trie? Edge n-grams?]</span></li>
<li>Fuzzy: <span class="fill-in">[Levenshtein distance?]</span></li>
<li>Ranking: <span class="fill-in">[BM25 + custom boost?]</span></li>
</ul>
<h3 id="scenario-2-log-search-observability">Scenario 2: Log Search (Observability)<a class="headerlink" href="#scenario-2-log-search-observability" title="Permanent link">&para;</a></h3>
<p><strong>Requirements:</strong></p>
<ul>
<li>1B log entries/day</li>
<li>Time-range queries</li>
<li>Full-text search on messages</li>
<li>Retention: 30 days</li>
<li>Real-time ingestion</li>
</ul>
<p><strong>Your design:</strong></p>
<p>Index strategy:</p>
<ul>
<li>Time-based indices: <span class="fill-in">[Daily? Hourly?]</span></li>
<li>Rollover policy: <span class="fill-in">[When?]</span></li>
<li>Deletion: <span class="fill-in">[How to handle retention?]</span></li>
</ul>
<p>Query optimization:</p>
<ul>
<li>Filter by time: <span class="fill-in">[Use filter context?]</span></li>
<li>Aggregations: <span class="fill-in">[Doc values?]</span></li>
<li>Pagination: <span class="fill-in">[Scroll API?]</span></li>
</ul>
<h3 id="scenario-3-knowledge-base-search">Scenario 3: Knowledge Base Search<a class="headerlink" href="#scenario-3-knowledge-base-search" title="Permanent link">&para;</a></h3>
<p><strong>Requirements:</strong></p>
<ul>
<li>100K articles</li>
<li>Multi-language support</li>
<li>Highlight search terms</li>
<li>"Did you mean?" suggestions</li>
<li>Related articles</li>
</ul>
<p><strong>Your design:</strong></p>
<p>Text analysis:</p>
<ul>
<li>Language detection: <span class="fill-in">[How?]</span></li>
<li>Stemming: <span class="fill-in">[Language-specific?]</span></li>
<li>Synonyms: <span class="fill-in">[How to implement?]</span></li>
</ul>
<p>Features:</p>
<ul>
<li>Highlighting: <span class="fill-in">[Unified? Plain?]</span></li>
<li>Suggestions: <span class="fill-in">[Fuzzy + frequency?]</span></li>
<li>Related: <span class="fill-in">[More Like This query?]</span></li>
</ul>
<hr />
<h2 id="review-checklist">Review Checklist<a class="headerlink" href="#review-checklist" title="Permanent link">&para;</a></h2>
<p>Before moving to the next topic:</p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> <strong>Understanding</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Understand inverted index structure</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Know tokenization pipeline</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Understand TF-IDF and BM25</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Know sharding and replication</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Understand query execution flow</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> <strong>Implementation</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Can design index mapping</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Know when to use analyzers</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Understand filter vs query context</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Can optimize queries</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> <strong>Decision Making</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Know when to shard</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Can choose ranking algorithm</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Understand trade-offs</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Completed practice scenarios</li>
</ul>
</li>
</ul>
<hr />
<h3 id="mastery-certification">Mastery Certification<a class="headerlink" href="#mastery-certification" title="Permanent link">&para;</a></h3>
<p><strong>I certify that I can:</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Explain inverted index structure</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Design search system for requirements</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Choose appropriate text analysis</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Implement ranking algorithms</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Optimize query performance</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Configure sharding strategy</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Debug search relevance issues</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Build autocomplete feature</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Handle multi-language search</li>
<li class="task-list-item"><label class="task-list-control"><input type="checkbox" disabled/><span class="task-list-indicator"></span></label> Teach search concepts to others</li>
</ul></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/java.min.js"></script>
                <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/python.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = "../.."</script>
    
    <script src="../../js/base.js"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
