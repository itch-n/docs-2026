<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="A framework for algorithms, systems design, and infrastructure." name="description"/>
<meta content="Richard" name="author"/>
<link href="../../img/favicon.ico" rel="shortcut icon"/>
<title>10. Graphs - Software Engineering Study Guide</title>
<link href="https://use.fontawesome.com/releases/v5.12.0/css/all.css" rel="stylesheet"/>
<link href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css" rel="stylesheet"/>
<link href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css" rel="stylesheet"/>
<link href="//rsms.me/inter/inter.css" rel="stylesheet" type="text/css"/>
<link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&amp;subset=latin-ext,latin" rel="stylesheet" type="text/css"/>
<link href="../../css/bootstrap-custom.min.css" rel="stylesheet"/>
<link href="../../css/base.min.css" rel="stylesheet"/>
<link href="../../css/cinder.min.css" rel="stylesheet"/>
<link href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css" rel="stylesheet"/>
<link href="../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->
</head>
<body>
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
<div class="container">
<!-- Collapsed navigation -->
<div class="navbar-header">
<!-- Expander button -->
<button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<!-- Main title -->
<a class="navbar-brand" href="../..">Software Engineering Study Guide</a>
</div>
<!-- Expanded navigation -->
<div class="navbar-collapse collapse">
<!-- Main navigation -->
<ul class="nav navbar-nav">
<li>
<a href="../..">Home</a>
</li>
<li class="dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#">Systems Design <b class="caret"></b></a>
<ul class="dropdown-menu">
<li>
<a href="../../systems/01-storage-engines/">01. Storage Engines</a>
</li>
<li>
<a href="../../systems/02-row-vs-column-storage/">02. Row vs Column Storage</a>
</li>
<li>
<a href="../../systems/03-networking-fundamentals/">03. Networking Fundamentals</a>
</li>
<li>
<a href="../../systems/04-search-and-indexing/">04. Search &amp; Indexing</a>
</li>
<li>
<a href="../../systems/05-caching-patterns/">05. Caching Patterns</a>
</li>
<li>
<a href="../../systems/06-api-design/">06. API Design</a>
</li>
<li>
<a href="../../systems/07-security-patterns/">07. Security Patterns</a>
</li>
<li>
<a href="../../systems/08-rate-limiting/">08. Rate Limiting</a>
</li>
<li>
<a href="../../systems/09-load-balancing/">09. Load Balancing</a>
</li>
<li>
<a href="../../systems/10-concurrency-patterns/">10. Concurrency Patterns</a>
</li>
<li>
<a href="../../systems/11-database-scaling/">11. Database Scaling</a>
</li>
<li>
<a href="../../systems/12-message-queues/">12. Message Queues</a>
</li>
<li>
<a href="../../systems/13-stream-processing/">13. Stream Processing</a>
</li>
<li>
<a href="../../systems/14-observability/">14. Observability</a>
</li>
<li>
<a href="../../systems/15-distributed-transactions/">15. Distributed Transactions</a>
</li>
<li>
<a href="../../systems/16-consensus-patterns/">16. Consensus Patterns</a>
</li>
</ul>
</li>
<li class="dropdown active">
<a class="dropdown-toggle" data-toggle="dropdown" href="#">DSA <b class="caret"></b></a>
<ul class="dropdown-menu">
<li>
<a href="../01-two-pointers/">01. Two Pointers</a>
</li>
<li>
<a href="../02-sliding-window/">02. Sliding Window</a>
</li>
<li>
<a href="../03-hash-tables/">03. Hash Tables</a>
</li>
<li>
<a href="../04-linked-lists/">04. Linked Lists</a>
</li>
<li>
<a href="../05-stacks--queues/">05. Stacks &amp; Queues</a>
</li>
<li>
<a href="../06-trees-traversals/">06. Trees - Traversals</a>
</li>
<li>
<a href="../07-trees-recursion/">07. Trees - Recursion</a>
</li>
<li>
<a href="../08-binary-search/">08. Binary Search</a>
</li>
<li>
<a href="../09-heaps/">09. Heaps</a>
</li>
<li class="active">
<a href="./">10. Graphs</a>
</li>
<li>
<a href="../11-union-find/">11. Union-Find</a>
</li>
<li>
<a href="../12-advanced-graphs/">12. Advanced Graphs</a>
</li>
<li>
<a href="../13-backtracking/">13. Backtracking</a>
</li>
<li>
<a href="../14-dynamic-programming-1d/">14. Dynamic Programming 1D</a>
</li>
<li>
<a href="../15-dynamic-programming-2d/">15. Dynamic Programming 2D</a>
</li>
<li>
<a href="../16-tries/">16. Tries</a>
</li>
<li>
<a href="../17-advanced-topics/">17. Advanced Topics</a>
</li>
</ul>
</li>
</ul>
<ul class="nav navbar-nav navbar-right">
<li>
<a data-target="#mkdocs_search_modal" data-toggle="modal" href="#">
<i class="fas fa-search"></i> Search
                        </a>
</li>
<li>
<a href="../09-heaps/" rel="prev">
<i class="fas fa-arrow-left"></i> Previous
                        </a>
</li>
<li>
<a href="../11-union-find/" rel="next">
                            Next <i class="fas fa-arrow-right"></i>
</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container">
<div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
<ul class="nav bs-sidenav">
<li class="first-level active"><a href="#graphs-traversal-patterns">Graphs: Traversal Patterns</a></li>
<li class="second-level"><a href="#eli5-explain-like-im-5">ELI5: Explain Like I'm 5</a></li>
<li class="second-level"><a href="#quick-quiz-do-before-implementing">Quick Quiz (Do BEFORE implementing)</a></li>
<li class="second-level"><a href="#beforeafter-why-this-pattern-matters">Before/After: Why This Pattern Matters</a></li>
<li class="second-level"><a href="#core-implementation">Core Implementation</a></li>
<li class="second-level"><a href="#debugging-challenges">Debugging Challenges</a></li>
<li class="second-level"><a href="#decision-framework">Decision Framework</a></li>
<li class="second-level"><a href="#practice">Practice</a></li>
<li class="second-level"><a href="#review-checklist">Review Checklist</a></li>
</ul>
</div></div>
<div class="col-md-9" role="main">
<h1 id="graphs-traversal-patterns">Graphs: Traversal Patterns<a class="headerlink" href="#graphs-traversal-patterns" title="Permanent link">¶</a></h1>
<blockquote>
<p>Master DFS, BFS, and cycle detection - the foundation for all graph problems</p>
</blockquote>
<hr/>
<h2 id="eli5-explain-like-im-5">ELI5: Explain Like I'm 5<a class="headerlink" href="#eli5-explain-like-im-5" title="Permanent link">¶</a></h2>
<div class="learner-section">
<p><strong>Your task:</strong> After implementing all patterns, explain them simply.</p>
<p><strong>Prompts to guide you:</strong></p>
<ol>
<li>
<p><strong>What is a graph in one sentence?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after implementation]</span></li>
</ul>
</li>
<li>
<p><strong>Why/when do we use graphs?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after implementation]</span></li>
</ul>
</li>
<li>
<p><strong>Real-world analogy:</strong></p>
<ul>
<li>Example: "A graph is like a social network where people are nodes and friendships are edges..."</li>
<li>Your analogy: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li>
<p><strong>What's the difference between DFS and BFS?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after solving problems]</span></li>
</ul>
</li>
<li>
<p><strong>When should you use DFS vs BFS?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after practice]</span></li>
</ul>
</li>
<li>
<p><strong>How do you detect cycles in graphs?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
</li>
</ol>
</div>
<hr/>
<h2 id="quick-quiz-do-before-implementing">Quick Quiz (Do BEFORE implementing)<a class="headerlink" href="#quick-quiz-do-before-implementing" title="Permanent link">¶</a></h2>
<div class="learner-section">
<p><strong>Your task:</strong> Test your intuition without looking at code. Answer these, then verify after implementation.</p>
<h3 id="complexity-predictions">Complexity Predictions<a class="headerlink" href="#complexity-predictions" title="Permanent link">¶</a></h3>
<ol>
<li>
<p><strong>BFS to find shortest path in unweighted graph:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Space complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Verified after learning: <span class="fill-in">[Actual: O(?)]</span></li>
</ul>
</li>
<li>
<p><strong>DFS to explore all paths in graph:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Space complexity (recursion stack): <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Verified: <span class="fill-in">[Actual]</span></li>
</ul>
</li>
</ol>
<h3 id="scenario-predictions">Scenario Predictions<a class="headerlink" href="#scenario-predictions" title="Permanent link">¶</a></h3>
<p><strong>Scenario 1:</strong> Find shortest path from A to E in graph: A→B→E, A→C→D→E</p>
<ul>
<li><strong>Which algorithm?</strong> <span class="fill-in">[BFS/DFS - Why?]</span></li>
<li><strong>BFS will find path in how many steps?</strong> <span class="fill-in">[Fill in]</span></li>
<li><strong>DFS might find which path first?</strong> <span class="fill-in">[Fill in]</span></li>
<li><strong>Why does BFS guarantee shortest?</strong> <span class="fill-in">[Explain]</span></li>
</ul>
<p><strong>Scenario 2:</strong> Detect if there's a cycle in a graph</p>
<ul>
<li><strong>Which algorithm?</strong> <span class="fill-in">[DFS/BFS - Why?]</span></li>
<li><strong>What data structure represents this?</strong> <span class="fill-in">[Directed/Undirected graph]</span></li>
<li><strong>How do you detect the cycle?</strong> <span class="fill-in">[Fill in your approach]</span></li>
</ul>
<p><strong>Scenario 3:</strong> Count number of islands in 2D grid</p>
<pre class="highlight"><code>[['1','1','0'],
 ['1','0','0'],
 ['0','0','1']]</code></pre>
<ul>
<li><strong>How many islands?</strong> <span class="fill-in">[Your guess]</span></li>
<li><strong>Which algorithm?</strong> <span class="fill-in">[DFS/BFS - Why?]</span></li>
<li><strong>What marks a cell as visited?</strong> <span class="fill-in">[Fill in]</span></li>
</ul>
<h3 id="trade-off-quiz">Trade-off Quiz<a class="headerlink" href="#trade-off-quiz" title="Permanent link">¶</a></h3>
<p><strong>Question 1:</strong> When would DFS be BETTER than BFS?</p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in before implementation]</span></li>
<li>Verified answer: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
<p><strong>Question 2:</strong> Adjacency Matrix vs Adjacency List - which is better for sparse graphs?</p>
<ul>
<li>Your answer: <span class="fill-in">[Matrix/List - Why?]</span></li>
<li>Space complexity comparison: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
<h3 id="graph-representation-quiz">Graph Representation Quiz<a class="headerlink" href="#graph-representation-quiz" title="Permanent link">¶</a></h3>
<p>Given graph: 0→1, 0→2, 1→3, 2→3</p>
<p><strong>Adjacency List representation:</strong></p>
<pre class="highlight"><code>Your answer:
&lt;span class="fill-in"&gt;[Draw/write the adjacency list structure]&lt;/span&gt;</code></pre>
<p><strong>Adjacency Matrix representation:</strong></p>
<pre class="highlight"><code>Your answer:
&lt;span class="fill-in"&gt;[Draw the 4x4 matrix]&lt;/span&gt;</code></pre>
<p><strong>Which uses less space?</strong> <span class="fill-in">[Fill in and explain why]</span></p>
</div>
<hr/>
<h2 id="beforeafter-why-this-pattern-matters">Before/After: Why This Pattern Matters<a class="headerlink" href="#beforeafter-why-this-pattern-matters" title="Permanent link">¶</a></h2>
<p><strong>Your task:</strong> Compare naive vs optimized approaches to understand the impact.</p>
<h3 id="example-1-find-shortest-path">Example 1: Find Shortest Path<a class="headerlink" href="#example-1-find-shortest-path" title="Permanent link">¶</a></h3>
<p><strong>Problem:</strong> Find shortest path between two nodes in an unweighted graph.</p>
<h4 id="approach-1-dfs-suboptimal">Approach 1: DFS (Suboptimal)<a class="headerlink" href="#approach-1-dfs-suboptimal" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Naive approach - DFS finds A path, not shortest path
public static int findPath_DFS(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start, int end) {
    Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
    return dfsPathLength(graph, start, end, visited, 0);
}

private static int dfsPathLength(Map&lt;Integer, List&lt;Integer&gt;&gt; graph,
                                 int current, int end, Set&lt;Integer&gt; visited, int length) {
    if (current == end) return length;
    if (visited.contains(current)) return Integer.MAX_VALUE;

    visited.add(current);
    int minPath = Integer.MAX_VALUE;

    for (int neighbor : graph.getOrDefault(current, new ArrayList&lt;&gt;())) {
        int pathLen = dfsPathLength(graph, neighbor, end, visited, length + 1);
        minPath = Math.min(minPath, pathLen);
    }

    visited.remove(current); // Backtrack
    return minPath;
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Time: O(V!) in worst case - explores all possible paths</li>
<li>Space: O(V) - recursion stack</li>
<li>Problem: Explores unnecessary paths, no guarantee of finding shortest first</li>
</ul>
<h4 id="approach-2-bfs-optimized">Approach 2: BFS (Optimized)<a class="headerlink" href="#approach-2-bfs-optimized" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Optimized approach - BFS guarantees shortest path
public static int findPath_BFS(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start, int end) {
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();

    queue.offer(start);
    visited.add(start);
    int length = 0;

    while (!queue.isEmpty()) {
        int size = queue.size();

        for (int i = 0; i &lt; size; i++) {
            int node = queue.poll();

            if (node == end) return length;

            for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
                if (!visited.contains(neighbor)) {
                    queue.offer(neighbor);
                    visited.add(neighbor);
                }
            }
        }
        length++;
    }

    return -1; // Not found
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Time: O(V + E) - visits each node and edge once</li>
<li>Space: O(V) - queue storage</li>
<li>Benefit: Explores level-by-level, first path found is shortest</li>
</ul>
<h4 id="performance-comparison">Performance Comparison<a class="headerlink" href="#performance-comparison" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Graph Size</th>
<th>DFS (worst case)</th>
<th>BFS</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>V = 10, E = 20</td>
<td>~3,628,800 ops (10!)</td>
<td>30 ops</td>
<td>~120,000x</td>
</tr>
<tr>
<td>V = 6, E = 10</td>
<td>~720 ops (6!)</td>
<td>16 ops</td>
<td>45x</td>
</tr>
<tr>
<td>V = 100, E = 200</td>
<td>Intractable</td>
<td>300 ops</td>
<td>Infinite</td>
</tr>
</tbody>
</table>
<p><strong>Your calculation:</strong> For a graph with V = 8 nodes, BFS would be approximately _____ times faster in worst case.</p>
<h4 id="why-does-bfs-find-shortest-path">Why Does BFS Find Shortest Path?<a class="headerlink" href="#why-does-bfs-find-shortest-path" title="Permanent link">¶</a></h4>
<p><strong>Key insight to understand:</strong></p>
<p>In graph A→B→D, A→C→D looking for path from A to D:</p>
<pre class="highlight"><code>BFS Level 0: [A]
BFS Level 1: [B, C]        (distance = 1 from A)
BFS Level 2: [D, D]        (distance = 2 from A, found first time)</code></pre>
<p>DFS might go: A → B → D (found) but doesn't know if A → C → D is shorter without exploring everything.</p>
<p><strong>Why BFS guarantees shortest:</strong></p>
<ul>
<li>Explores all nodes at distance k before distance k+1</li>
<li>First time we reach target = minimum distance</li>
<li>No need to explore further paths</li>
</ul>
<p><strong>After implementing, explain in your own words:</strong></p>
<div class="learner-section">
<ul>
<li>Why does level-order exploration matter? <span class="fill-in">[Your answer]</span></li>
<li>When would DFS accidentally find shortest path? <span class="fill-in">[Your answer]</span></li>
</ul>
</div>
<hr/>
<h3 id="example-2-graph-representation">Example 2: Graph Representation<a class="headerlink" href="#example-2-graph-representation" title="Permanent link">¶</a></h3>
<p><strong>Problem:</strong> Store graph with 1000 nodes and 5000 edges.</p>
<h4 id="approach-1-adjacency-matrix">Approach 1: Adjacency Matrix<a class="headerlink" href="#approach-1-adjacency-matrix" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Matrix representation - simple but space-inefficient for sparse graphs
public class GraphMatrix {
    private int[][] matrix;
    private int V;

    public GraphMatrix(int vertices) {
        this.V = vertices;
        this.matrix = new int[V][V];
    }

    public void addEdge(int src, int dst) {
        matrix[src][dst] = 1;  // O(1) to add
    }

    public boolean hasEdge(int src, int dst) {
        return matrix[src][dst] == 1;  // O(1) to check
    }

    public List&lt;Integer&gt; getNeighbors(int node) {
        List&lt;Integer&gt; neighbors = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; V; i++) {
            if (matrix[node][i] == 1) {
                neighbors.add(i);
            }
        }
        return neighbors;  // O(V) to get all neighbors
    }
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Space: O(V²) = O(1,000,000) for 1000 nodes</li>
<li>Add edge: O(1)</li>
<li>Check edge: O(1)</li>
<li>Get neighbors: O(V)</li>
<li>Memory usage: 1000 × 1000 = 1,000,000 integers ≈ 4 MB</li>
</ul>
<h4 id="approach-2-adjacency-list">Approach 2: Adjacency List<a class="headerlink" href="#approach-2-adjacency-list" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// List representation - space-efficient for sparse graphs
public class GraphList {
    private Map&lt;Integer, List&lt;Integer&gt;&gt; adjList;

    public GraphList() {
        this.adjList = new HashMap&lt;&gt;();
    }

    public void addEdge(int src, int dst) {
        adjList.computeIfAbsent(src, k -&gt; new ArrayList&lt;&gt;()).add(dst);  // O(1) average
    }

    public boolean hasEdge(int src, int dst) {
        return adjList.getOrDefault(src, new ArrayList&lt;&gt;()).contains(dst);  // O(degree)
    }

    public List&lt;Integer&gt; getNeighbors(int node) {
        return adjList.getOrDefault(node, new ArrayList&lt;&gt;());  // O(1) to get list
    }
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Space: O(V + E) = O(1000 + 5000) = O(6000)</li>
<li>Add edge: O(1) average</li>
<li>Check edge: O(degree of node)</li>
<li>Get neighbors: O(1)</li>
<li>Memory usage: ~6000 integers ≈ 24 KB</li>
</ul>
<h4 id="space-comparison">Space Comparison<a class="headerlink" href="#space-comparison" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Graph Type</th>
<th>Adjacency Matrix</th>
<th>Adjacency List</th>
<th>Better Choice</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dense (V=1000, E=500,000)</td>
<td>1M ints (4 MB)</td>
<td>501K ints (2 MB)</td>
<td>Matrix (similar)</td>
</tr>
<tr>
<td>Sparse (V=1000, E=5000)</td>
<td>1M ints (4 MB)</td>
<td>6K ints (24 KB)</td>
<td><strong>List (167x less)</strong></td>
</tr>
<tr>
<td>Very Sparse (V=1000, E=100)</td>
<td>1M ints (4 MB)</td>
<td>1.1K ints (4 KB)</td>
<td><strong>List (1000x less)</strong></td>
</tr>
</tbody>
</table>
<p><strong>Your calculation:</strong> For V = 5000 nodes and E = 10,000 edges, adjacency list uses _____ less space than matrix.</p>
<h4 id="when-to-use-each">When to Use Each?<a class="headerlink" href="#when-to-use-each" title="Permanent link">¶</a></h4>
<p><strong>Use Adjacency Matrix when:</strong></p>
<ul>
<li>Graph is dense (E ≈ V²)</li>
<li>Need O(1) edge existence checks frequently</li>
<li>All operations need to be simple array lookups</li>
</ul>
<p><strong>Use Adjacency List when:</strong></p>
<ul>
<li>Graph is sparse (E &lt;&lt; V²)</li>
<li>Need to iterate through neighbors frequently</li>
<li>Memory is limited</li>
</ul>
<p><strong>After implementing, explain in your own words:</strong></p>
<div class="learner-section">
<ul>
<li>Why does sparse vs dense matter? <span class="fill-in">[Your answer]</span></li>
<li>What operations are faster with each representation? <span class="fill-in">[Your answer]</span></li>
</ul>
</div>
<hr/>
<h2 id="core-implementation">Core Implementation<a class="headerlink" href="#core-implementation" title="Permanent link">¶</a></h2>
<h3 id="pattern-1-dfs-depth-first-search">Pattern 1: DFS (Depth-First Search)<a class="headerlink" href="#pattern-1-dfs-depth-first-search" title="Permanent link">¶</a></h3>
<p><strong>Concept:</strong> Explore as far as possible along each branch before backtracking.</p>
<p><strong>Use case:</strong> Detect cycles, find paths, connected components, backtracking problems.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class DFS {

    /**
     * Problem: Number of islands (connected components)
     * Time: O(m*n), Space: O(m*n) for recursion stack
     *
     * TODO: Implement DFS to count islands
     */
    public static int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int count = 0;

        // TODO: Implement iteration/conditional logic

        return 0; // Replace with implementation
    }

    private static void dfs(char[][] grid, int i, int j) {
        // TODO: Base cases

        // TODO: Implement logic

        // TODO: Recursively visit 4 neighbors
    }

    /**
     * Problem: Has path in graph (adjacency list)
     * Time: O(V + E), Space: O(V)
     *
     * TODO: Implement DFS path finding
     */
    public static boolean hasPath(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start, int end) {
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();

        // TODO: Call recursive DFS helper
        return false; // Replace
    }

    private static boolean dfsPath(Map&lt;Integer, List&lt;Integer&gt;&gt; graph,
                                   int current, int target, Set&lt;Integer&gt; visited) {
        // TODO: Implement iteration/conditional logic

        // TODO: Implement iteration/conditional logic

        // TODO: Mark current as visited

        // TODO: Implement iteration/conditional logic

        // TODO: Return false if no path found

        return false; // Replace
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class DFSClient {

    public static void main(String[] args) {
        System.out.println("=== DFS Pattern ===\n");

        // Test 1: Number of islands
        System.out.println("--- Test 1: Number of Islands ---");
        char[][] grid1 = {
            {'1','1','0','0','0'},
            {'1','1','0','0','0'},
            {'0','0','1','0','0'},
            {'0','0','0','1','1'}
        };

        System.out.println("Grid:");
        for (char[] row : grid1) {
            System.out.println(Arrays.toString(row));
        }
        System.out.println("Islands: " + DFS.numIslands(grid1));

        // Test 2: Has path
        System.out.println("\n--- Test 2: Has Path ---");
        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(3));
        graph.put(2, Arrays.asList(3));
        graph.put(3, Arrays.asList());

        System.out.println("Graph: " + graph);
        System.out.println("Path 0 -&gt; 3? " + DFS.hasPath(graph, 0, 3));
        System.out.println("Path 0 -&gt; 4? " + DFS.hasPath(graph, 0, 4));
    }
}</code></pre>
<hr/>
<h3 id="pattern-2-bfs-breadth-first-search">Pattern 2: BFS (Breadth-First Search)<a class="headerlink" href="#pattern-2-bfs-breadth-first-search" title="Permanent link">¶</a></h3>
<p><strong>Concept:</strong> Explore all neighbors at current depth before moving deeper.</p>
<p><strong>Use case:</strong> Shortest path in unweighted graph, level-order traversal, minimum steps.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class BFS {

    /**
     * Problem: Shortest path in unweighted graph
     * Time: O(V + E), Space: O(V)
     *
     * TODO: Implement BFS shortest path
     */
    public static int shortestPath(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start, int end) {
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
        int steps = 0;

        // TODO: Add start to queue and visited

        // TODO: Implement iteration/conditional logic

        return -1; // Not found
    }

    /**
     * Problem: Minimum knight moves to reach target
     * Time: O(n^2), Space: O(n^2)
     *
     * TODO: Implement BFS for chess board
     */
    public static int minKnightMoves(int targetX, int targetY) {
        int[][] directions = {{2,1}, {2,-1}, {-2,1}, {-2,-1},
                              {1,2}, {1,-2}, {-1,2}, {-1,-2}};

        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        Set&lt;String&gt; visited = new HashSet&lt;&gt;();

        // TODO: Start from (0, 0)

        int moves = 0;

        // TODO: Implement iteration/conditional logic

        return -1; // Replace
    }

    /**
     * Problem: Rotting oranges (multi-source BFS)
     * Time: O(m*n), Space: O(m*n)
     *
     * TODO: Implement multi-source BFS
     */
    public static int orangesRotting(int[][] grid) {
        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        int fresh = 0;
        int minutes = 0;

        // TODO: Count fresh oranges and add rotten to queue

        // TODO: BFS to rot adjacent oranges

        // TODO: Return minutes if all fresh rotted, else -1

        return 0; // Replace
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class BFSClient {

    public static void main(String[] args) {
        System.out.println("=== BFS Pattern ===\n");

        // Test 1: Shortest path
        System.out.println("--- Test 1: Shortest Path ---");
        Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(3));
        graph.put(2, Arrays.asList(3, 4));
        graph.put(3, Arrays.asList(4));
        graph.put(4, Arrays.asList());

        System.out.println("Graph: " + graph);
        System.out.println("Shortest path 0 -&gt; 4: " + BFS.shortestPath(graph, 0, 4));

        // Test 2: Knight moves
        System.out.println("\n--- Test 2: Knight Moves ---");
        int[][] targets = {{2, 1}, {5, 5}};
        for (int[] target : targets) {
            int moves = BFS.minKnightMoves(target[0], target[1]);
            System.out.printf("To (%d, %d): %d moves%n", target[0], target[1], moves);
        }

        // Test 3: Rotting oranges
        System.out.println("\n--- Test 3: Rotting Oranges ---");
        int[][] grid = {
            {2, 1, 1},
            {1, 1, 0},
            {0, 1, 1}
        };

        System.out.println("Grid:");
        for (int[] row : grid) {
            System.out.println(Arrays.toString(row));
        }
        System.out.println("Minutes to rot all: " + BFS.orangesRotting(grid));
    }
}</code></pre>
<hr/>
<h3 id="pattern-3-cycle-detection">Pattern 3: Cycle Detection<a class="headerlink" href="#pattern-3-cycle-detection" title="Permanent link">¶</a></h3>
<p><strong>Interview Priority: ⭐⭐⭐ CRITICAL</strong> - Cycle detection is essential for many graph problems</p>
<p><strong>Concept:</strong> Detect if graph contains a cycle.</p>
<p><strong>Use case:</strong> Validate DAG, detect deadlocks, dependency resolution.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class CycleDetection {

    /**
     * Problem: Detect cycle in directed graph
     * Time: O(V + E), Space: O(V)
     *
     * TODO: Implement using DFS with states
     */
    public static boolean hasCycleDirected(int n, int[][] edges) {
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
        int[] state = new int[n]; // 0: unvisited, 1: visiting, 2: visited

        // TODO: Build graph

        // TODO: DFS from each unvisited node

        return false; // Replace
    }

    private static boolean dfsCycleDirected(List&lt;List&lt;Integer&gt;&gt; graph, int node, int[] state) {
        // TODO: Implement iteration/conditional logic

        // TODO: Implement iteration/conditional logic

        // TODO: Mark as visiting

        // TODO: Visit all neighbors

        // TODO: Mark as visited

        return false; // Replace
    }

    /**
     * Problem: Detect cycle in undirected graph
     * Time: O(V + E), Space: O(V)
     *
     * TODO: Implement using DFS with parent tracking
     */
    public static boolean hasCycleUndirected(int n, int[][] edges) {
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
        boolean[] visited = new boolean[n];

        // TODO: Build graph (both directions for undirected)

        // TODO: DFS from each unvisited component

        return false; // Replace
    }

    private static boolean dfsCycleUndirected(List&lt;List&lt;Integer&gt;&gt; graph, int node,
                                             int parent, boolean[] visited) {
        // TODO: Mark as visited

        // TODO: Visit all neighbors

        return false; // Replace
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class CycleDetectionClient {

    public static void main(String[] args) {
        System.out.println("=== Cycle Detection ===\n");

        // Test 1: Directed graph cycle
        System.out.println("--- Test 1: Directed Graph ---");
        int[][] edges1 = {{0, 1}, {1, 2}};
        int[][] edges2 = {{0, 1}, {1, 2}, {2, 0}};

        System.out.println("Edges [[0,1],[1,2]]: " +
            CycleDetection.hasCycleDirected(3, edges1));
        System.out.println("Edges [[0,1],[1,2],[2,0]]: " +
            CycleDetection.hasCycleDirected(3, edges2));

        // Test 2: Undirected graph cycle
        System.out.println("\n--- Test 2: Undirected Graph ---");
        int[][] edges3 = {{0, 1}, {1, 2}};
        int[][] edges4 = {{0, 1}, {1, 2}, {2, 0}};

        System.out.println("Edges [[0,1],[1,2]]: " +
            CycleDetection.hasCycleUndirected(3, edges3));
        System.out.println("Edges [[0,1],[1,2],[2,0]]: " +
            CycleDetection.hasCycleUndirected(3, edges4));
    }
}</code></pre>
<hr/>
<h2 id="debugging-challenges">Debugging Challenges<a class="headerlink" href="#debugging-challenges" title="Permanent link">¶</a></h2>
<p><strong>Your task:</strong> Find and fix bugs in broken graph implementations. This tests your understanding.</p>
<h3 id="challenge-1-broken-dfs-visited-array-bug">Challenge 1: Broken DFS - Visited Array Bug<a class="headerlink" href="#challenge-1-broken-dfs-visited-array-bug" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * This code is supposed to count connected components using DFS.
 * It has 2 BUGS. Find them!
 */
public static int countComponents_Buggy(int n, int[][] edges) {
    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();

    // Build graph
    for (int i = 0; i &lt; n; i++) {
        graph.put(i, new ArrayList&lt;&gt;());
    }
    for (int[] edge : edges) {
        graph.get(edge[0]).add(edge[1]);
        graph.get(edge[1]).add(edge[0]);
    }

    boolean[] visited = new boolean[n];
    int count = 0;

    for (int i = 0; i &lt; n; i++) {
        if (!visited[i]) {
            dfs(graph, i, visited);        }
    }

    return count;}

private static void dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int node, boolean[] visited) {
    visited[node] = true;

    for (int neighbor : graph.get(node)) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited);
        }
    }
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li>
<p>Bug 1: <span class="fill-in">[What\'s the bug?]</span></p>
</li>
<li>
<p>Bug 2: <span class="fill-in">[What\'s the bug?]</span></p>
</li>
</ul>
<p><strong>Test case:</strong></p>
<ul>
<li>Input: n = 5, edges = [[0,1], [1,2], [3,4]]</li>
<li>Expected: 2 components</li>
<li>Actual with buggy code: <span class="fill-in">[What do you get?]</span></li>
</ul>
<details>
<summary>Click to verify your answers</summary>
<p><strong>Bug 1 (Line 18):</strong> After calling <code>dfs()</code>, we never increment <code>count</code>! Should be:</p>
<pre class="highlight"><code class="language-java">if (!visited[i]) {
    dfs(graph, i, visited);
    count++;  // Increment after exploring component
}</code></pre>
<p><strong>Bug 2:</strong> Actually the same as Bug 1. The <code>count</code> variable is initialized but never incremented, so it always returns
0.</p>
<p><strong>Correct fix:</strong></p>
<pre class="highlight"><code class="language-java">for (int i = 0; i &lt; n; i++) {
    if (!visited[i]) {
        dfs(graph, i, visited);
        count++;
    }
}
return count;</code></pre>
</details>
<hr/>
<h3 id="challenge-2-broken-bfs-level-tracking-bug">Challenge 2: Broken BFS - Level Tracking Bug<a class="headerlink" href="#challenge-2-broken-bfs-level-tracking-bug" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * Find shortest path length using BFS.
 * This has 1 CRITICAL BUG that causes wrong results.
 */
public static int shortestPath_Buggy(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int start, int end) {
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();
    int distance = 0;

    queue.offer(start);

    while (!queue.isEmpty()) {
        int node = queue.poll();
        if (node == end) return distance;

        for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
            if (!visited.contains(neighbor)) {
                queue.offer(neighbor);
                visited.add(neighbor);
            }
        }

        distance++;
    }

    return -1;
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li><strong>Bug 1:</strong> <span class="fill-in">[What's missing after queue.offer(start)?]</span></li>
<li><strong>Bug 2:</strong> <span class="fill-in">[How should we process the queue by level?]</span></li>
<li><strong>Why it fails:</strong> <span class="fill-in">[Trace through with start=0, end=2, graph: 0→1, 1→2]</span></li>
</ul>
<p><strong>Expected distance:</strong> 2
<strong>Actual with buggy code:</strong> <span class="fill-in">[What do you get?]</span></p>
<details>
<summary>Click to verify your answer</summary>
<p><strong>Bug 1:</strong> Missing <code>visited.add(start)</code> after adding start to queue. Without this, we might revisit the start node.</p>
<p><strong>Bug 2:</strong> Not processing nodes level-by-level. Should use:</p>
<pre class="highlight"><code class="language-java">while (!queue.isEmpty()) {
    int size = queue.size();  // Process all nodes at current level

    for (int i = 0; i &lt; size; i++) {
        int node = queue.poll();

        if (node == end) return distance;

        for (int neighbor : graph.getOrDefault(node, new ArrayList&lt;&gt;())) {
            if (!visited.contains(neighbor)) {
                queue.offer(neighbor);
                visited.add(neighbor);
            }
        }
    }

    distance++;  // Increment after processing entire level
}</code></pre>
<p><strong>Why:</strong> Without level-by-level processing, <code>distance</code> increments for every node polled, not for each level.</p>
</details>
<hr/>
<h3 id="challenge-3-wrong-adjacency-representation">Challenge 3: Wrong Adjacency Representation<a class="headerlink" href="#challenge-3-wrong-adjacency-representation" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * Build graph from edge list for undirected graph.
 * This has 1 LOGIC BUG.
 */
public static Map&lt;Integer, List&lt;Integer&gt;&gt; buildGraph_Buggy(int n, int[][] edges) {
    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();

    for (int i = 0; i &lt; n; i++) {
        graph.put(i, new ArrayList&lt;&gt;());
    }

    for (int[] edge : edges) {
        int u = edge[0], v = edge[1];
        graph.get(u).add(v);    }

    return graph;
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li><strong>Bug:</strong> <span class="fill-in">[What's missing for undirected graphs?]</span></li>
<li><strong>What happens:</strong> <span class="fill-in">[Can you find the path with buggy graph?]</span></li>
</ul>
<details>
<summary>Click to verify your answer</summary>
<p><strong>Bug:</strong> For undirected graphs, need to add edge in BOTH directions:</p>
<pre class="highlight"><code class="language-java">for (int[] edge : edges) {
    int u = edge[0], v = edge[1];
    graph.get(u).add(v);
    graph.get(v).add(u);  // Add reverse edge!
}</code></pre>
<p><strong>Why:</strong> In an undirected graph, edge (u,v) means both u→v and v→u. Without the reverse edge, the graph is incorrectly
treated as directed.</p>
</details>
<hr/>
<h3 id="your-debugging-scorecard">Your Debugging Scorecard<a class="headerlink" href="#your-debugging-scorecard" title="Permanent link">¶</a></h3>
<p>After finding and fixing all bugs:</p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Found all 5 bugs across 3 challenges</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understood WHY each bug causes incorrect behavior</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could explain the fix to someone else</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Learned common graph traversal mistakes to avoid</li>
</ul>
<p><strong>Common graph mistakes you discovered:</strong></p>
<ol>
<li><span class="fill-in">[Forgetting to increment counter after DFS]</span></li>
<li><span class="fill-in">[Not marking start node as visited in BFS]</span></li>
<li><span class="fill-in">[Not processing BFS level-by-level]</span></li>
<li><span class="fill-in">[Not adding both directions for undirected graphs]</span></li>
<li><span class="fill-in">[Fill in more patterns you noticed]</span></li>
</ol>
<hr/>
<h2 id="decision-framework">Decision Framework<a class="headerlink" href="#decision-framework" title="Permanent link">¶</a></h2>
<p><strong>Your task:</strong> Build decision trees for when to use each graph algorithm.</p>
<h3 id="question-1-dfs-vs-bfs-which-to-use">Question 1: DFS vs BFS - Which to use?<a class="headerlink" href="#question-1-dfs-vs-bfs-which-to-use" title="Permanent link">¶</a></h3>
<p>Answer after solving problems:</p>
<p><strong>Use DFS when:</strong></p>
<ul>
<li>Need to explore all paths: <span class="fill-in">[Backtracking, cycle detection]</span></li>
<li>Memory is limited: <span class="fill-in">[DFS uses less space]</span></li>
<li>Finding any path (not shortest): <span class="fill-in">[Fill in]</span></li>
</ul>
<p><strong>Use BFS when:</strong></p>
<ul>
<li>Need shortest path: <span class="fill-in">[Unweighted graphs]</span></li>
<li>Level-order traversal: <span class="fill-in">[Process by distance from source]</span></li>
<li>Multi-source problems: <span class="fill-in">[Fill in examples]</span></li>
</ul>
<h3 id="question-2-graph-representation">Question 2: Graph representation?<a class="headerlink" href="#question-2-graph-representation" title="Permanent link">¶</a></h3>
<p><strong>Adjacency List:</strong></p>
<ul>
<li>Use when: <span class="fill-in">[Sparse graphs, need to iterate neighbors]</span></li>
<li>Space: <span class="fill-in">[O(V + E)]</span></li>
</ul>
<p><strong>Adjacency Matrix:</strong></p>
<ul>
<li>Use when: <span class="fill-in">[Dense graphs, need to check edge existence]</span></li>
<li>Space: <span class="fill-in">[O(V²)]</span></li>
</ul>
<h3 id="your-decision-tree">Your Decision Tree<a class="headerlink" href="#your-decision-tree" title="Permanent link">¶</a></h3>
<p>Build this after solving practice problems:
<div class="mermaid">flowchart TD
    Start["Graph Traversal Problem"]

    Q1{"Need shortest path&lt;br/&gt;(unweighted)?"}
    Start --&gt; Q1
    BFS(["BFS ✓"])
    Q1 --&gt;|"Yes"| BFS

    Q2{"Explore all paths&lt;br/&gt;or backtrack?"}
    Q1 --&gt;|"No"| Q2
    DFS1(["DFS ✓"])
    Q2 --&gt;|"Yes"| DFS1

    Q3{"Detect cycle?"}
    Q2 --&gt;|"No"| Q3
    DFS2(["DFS with states ✓"])
    Q3 --&gt;|"Directed"| DFS2
    DFS3(["DFS with parent ✓"])
    Q3 --&gt;|"Undirected"| DFS3

    Q4{"Count components?"}
    Q3 --&gt;|"No"| Q4
    DFSBFS(["DFS or BFS ✓"])
    Q4 --&gt;|"Yes"| DFSBFS</div></p>
<p><strong>Note:</strong> For weighted graphs, topological sort, and MST problems, see "Advanced Graph Algorithms"</p>
<hr/>
<h2 id="practice">Practice<a class="headerlink" href="#practice" title="Permanent link">¶</a></h2>
<h3 id="leetcode-problems">LeetCode Problems<a class="headerlink" href="#leetcode-problems" title="Permanent link">¶</a></h3>
<p><strong>Interview Priority:</strong> Focus on these patterns - they appear in 60% of graph interviews</p>
<p><strong>Easy (Complete 2-3):</strong></p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/find-the-town-judge/">997. Find the Town Judge</a> ⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[Graph properties]</span></li>
<li>Your solution time: <span class="fill-in">___</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/find-if-path-exists-in-graph/">1971. Find if Path Exists in Graph</a> ⭐⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[DFS/BFS]</span></li>
<li>Your solution time: <span class="fill-in">___</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
</ul>
<p><strong>Medium (Complete ALL - these are critical):</strong></p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/number-of-islands/">200. Number of Islands</a> ⭐⭐⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[DFS]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/clone-graph/">133. Clone Graph</a> ⭐⭐⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[DFS/BFS]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/rotting-oranges/">994. Rotting Oranges</a> ⭐⭐⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[Multi-source BFS]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/pacific-atlantic-water-flow/">417. Pacific Atlantic Water Flow</a> ⭐⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[DFS/BFS from multiple sources]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/graph-valid-tree/">261. Graph Valid Tree</a> ⭐⭐</p>
<ul>
<li>Pattern: <span class="fill-in">[Cycle detection]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
</ul>
<p><strong>Hard (Optional):</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/word-ladder/">127. Word Ladder</a> ⭐⭐<ul>
<li>Pattern: <span class="fill-in">[BFS]</span></li>
<li>Key insight: <span class="fill-in">[Fill in after solving]</span></li>
</ul>
</li>
</ul>
<p><strong>Next step:</strong> After mastering these, move to "Advanced Graph Algorithms" for Course Schedule, Dijkstra, MST</p>
<hr/>
<h2 id="review-checklist">Review Checklist<a class="headerlink" href="#review-checklist" title="Permanent link">¶</a></h2>
<p>Before moving to Advanced Graph Algorithms:</p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Implementation</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> DFS: islands, path finding, cycle detection all work</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> BFS: shortest path, multi-source BFS (rotting oranges) work</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Cycle detection: directed and undirected work</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Graph representations: can build adjacency list/matrix</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> All client code runs successfully</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Pattern Recognition</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Can identify when to use DFS vs BFS</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Know how to detect cycles in both directed/undirected graphs</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understand graph representation trade-offs (list vs matrix)</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Recognize multi-source BFS patterns</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Problem Solving</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Solved 2-3 easy problems</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Solved 5 core medium problems (Islands, Clone Graph, Rotting Oranges, etc.)</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Analyzed time/space complexity</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Handled edge cases (empty graph, disconnected components)</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Understanding</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Filled in all ELI5 explanations</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Built decision tree</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Can explain DFS vs BFS trade-offs</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Know when NOT to use each traversal method</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understand why BFS finds shortest path in unweighted graphs</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Mastery Check</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could implement DFS/BFS/cycle detection from memory</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could recognize traversal pattern in new problem</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could explain to someone else</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understand why each algorithm works</li>
</ul>
</li>
</ul>
<hr/>
<h3 id="mastery-certification">Mastery Certification<a class="headerlink" href="#mastery-certification" title="Permanent link">¶</a></h3>
<p><strong>I certify that I can:</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Implement DFS and BFS from memory</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Explain when to use DFS vs BFS</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Detect cycles in directed and undirected graphs</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Choose appropriate graph representation (list vs matrix)</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Identify graph traversal patterns in new problems</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Analyze time and space complexity</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Debug common graph traversal mistakes</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Teach these concepts to someone else</li>
</ul></div>
</div>
<footer class="col-md-12 text-center">
<hr/>
<p>
<small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
</p>
</footer>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="../../js/bootstrap-3.0.3.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/java.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/python.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>var base_url = "../.."</script>
<script src="../../js/base.js"></script>
<script src="../../search/main.js"></script>
<div aria-hidden="true" aria-labelledby="searchModalLabel" class="modal" id="mkdocs_search_modal" role="dialog" tabindex="-1">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<button class="close" data-dismiss="modal" type="button">
<span aria-hidden="true">×</span>
<span class="sr-only">Close</span>
</button>
<h4 class="modal-title" id="searchModalLabel">Search</h4>
</div>
<div class="modal-body">
<p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
<form>
<div class="form-group">
<input class="form-control" id="mkdocs-search-query" placeholder="Search..." title="Type search term here" type="text"/>
</div>
</form>
<div id="mkdocs-search-results"></div>
</div>
<div class="modal-footer">
</div>
</div>
</div>
</div><div aria-hidden="true" aria-labelledby="keyboardModalLabel" class="modal" id="mkdocs_keyboard_modal" role="dialog" tabindex="-1">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
<button class="close" data-dismiss="modal" type="button"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>
</div>
<div class="modal-body">
<table class="table">
<thead>
<tr>
<th style="width: 20%;">Keys</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="help shortcut"><kbd>?</kbd></td>
<td>Open this help</td>
</tr>
<tr>
<td class="next shortcut"><kbd>n</kbd></td>
<td>Next page</td>
</tr>
<tr>
<td class="prev shortcut"><kbd>p</kbd></td>
<td>Previous page</td>
</tr>
<tr>
<td class="search shortcut"><kbd>s</kbd></td>
<td>Search</td>
</tr>
</tbody>
</table>
</div>
<div class="modal-footer">
</div>
</div>
</div>
</div>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>
