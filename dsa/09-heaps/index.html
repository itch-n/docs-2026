<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="A framework for algorithms, systems design, and infrastructure." name="description"/>
<meta content="Richard" name="author"/>
<link href="../../img/favicon.ico" rel="shortcut icon"/>
<title>09. Heaps - Software Engineering Study Guide</title>
<link href="https://use.fontawesome.com/releases/v5.12.0/css/all.css" rel="stylesheet"/>
<link href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css" rel="stylesheet"/>
<link href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css" rel="stylesheet"/>
<link href="//rsms.me/inter/inter.css" rel="stylesheet" type="text/css"/>
<link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&amp;subset=latin-ext,latin" rel="stylesheet" type="text/css"/>
<link href="../../css/bootstrap-custom.min.css" rel="stylesheet"/>
<link href="../../css/base.min.css" rel="stylesheet"/>
<link href="../../css/cinder.min.css" rel="stylesheet"/>
<link href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css" rel="stylesheet"/>
<link href="../../css/custom.css" rel="stylesheet"/>
<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->
</head>
<body>
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
<div class="container">
<!-- Collapsed navigation -->
<div class="navbar-header">
<!-- Expander button -->
<button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse" type="button">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<!-- Main title -->
<a class="navbar-brand" href="../..">Software Engineering Study Guide</a>
</div>
<!-- Expanded navigation -->
<div class="navbar-collapse collapse">
<!-- Main navigation -->
<ul class="nav navbar-nav">
<li>
<a href="../..">Home</a>
</li>
<li class="dropdown">
<a class="dropdown-toggle" data-toggle="dropdown" href="#">Systems Design <b class="caret"></b></a>
<ul class="dropdown-menu">
<li>
<a href="../../systems/01-storage-engines/">01. Storage Engines</a>
</li>
<li>
<a href="../../systems/02-row-vs-column-storage/">02. Row vs Column Storage</a>
</li>
<li>
<a href="../../systems/03-networking-fundamentals/">03. Networking Fundamentals</a>
</li>
<li>
<a href="../../systems/04-search-and-indexing/">04. Search &amp; Indexing</a>
</li>
<li>
<a href="../../systems/05-caching-patterns/">05. Caching Patterns</a>
</li>
<li>
<a href="../../systems/06-api-design/">06. API Design</a>
</li>
<li>
<a href="../../systems/07-security-patterns/">07. Security Patterns</a>
</li>
<li>
<a href="../../systems/08-rate-limiting/">08. Rate Limiting</a>
</li>
<li>
<a href="../../systems/09-load-balancing/">09. Load Balancing</a>
</li>
<li>
<a href="../../systems/10-concurrency-patterns/">10. Concurrency Patterns</a>
</li>
<li>
<a href="../../systems/11-database-scaling/">11. Database Scaling</a>
</li>
<li>
<a href="../../systems/12-message-queues/">12. Message Queues</a>
</li>
<li>
<a href="../../systems/13-stream-processing/">13. Stream Processing</a>
</li>
<li>
<a href="../../systems/14-observability/">14. Observability</a>
</li>
<li>
<a href="../../systems/15-distributed-transactions/">15. Distributed Transactions</a>
</li>
<li>
<a href="../../systems/16-consensus-patterns/">16. Consensus Patterns</a>
</li>
</ul>
</li>
<li class="dropdown active">
<a class="dropdown-toggle" data-toggle="dropdown" href="#">DSA <b class="caret"></b></a>
<ul class="dropdown-menu">
<li>
<a href="../01-two-pointers/">01. Two Pointers</a>
</li>
<li>
<a href="../02-sliding-window/">02. Sliding Window</a>
</li>
<li>
<a href="../03-hash-tables/">03. Hash Tables</a>
</li>
<li>
<a href="../04-linked-lists/">04. Linked Lists</a>
</li>
<li>
<a href="../05-stacks--queues/">05. Stacks &amp; Queues</a>
</li>
<li>
<a href="../06-trees-traversals/">06. Trees - Traversals</a>
</li>
<li>
<a href="../07-trees-recursion/">07. Trees - Recursion</a>
</li>
<li>
<a href="../08-binary-search/">08. Binary Search</a>
</li>
<li class="active">
<a href="./">09. Heaps</a>
</li>
<li>
<a href="../10-graphs/">10. Graphs</a>
</li>
<li>
<a href="../11-union-find/">11. Union-Find</a>
</li>
<li>
<a href="../12-advanced-graphs/">12. Advanced Graphs</a>
</li>
<li>
<a href="../13-backtracking/">13. Backtracking</a>
</li>
<li>
<a href="../14-dynamic-programming-1d/">14. Dynamic Programming 1D</a>
</li>
<li>
<a href="../15-dynamic-programming-2d/">15. Dynamic Programming 2D</a>
</li>
<li>
<a href="../16-tries/">16. Tries</a>
</li>
<li>
<a href="../17-advanced-topics/">17. Advanced Topics</a>
</li>
</ul>
</li>
</ul>
<ul class="nav navbar-nav navbar-right">
<li>
<a data-target="#mkdocs_search_modal" data-toggle="modal" href="#">
<i class="fas fa-search"></i> Search
                        </a>
</li>
<li>
<a href="../08-binary-search/" rel="prev">
<i class="fas fa-arrow-left"></i> Previous
                        </a>
</li>
<li>
<a href="../10-graphs/" rel="next">
                            Next <i class="fas fa-arrow-right"></i>
</a>
</li>
</ul>
</div>
</div>
</div>
<div class="container">
<div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
<ul class="nav bs-sidenav">
<li class="first-level active"><a href="#heaps-priority-queues">Heaps (Priority Queues)</a></li>
<li class="second-level"><a href="#eli5-explain-like-im-5">ELI5: Explain Like I'm 5</a></li>
<li class="second-level"><a href="#quick-quiz-do-before-implementing">Quick Quiz (Do BEFORE implementing)</a></li>
<li class="second-level"><a href="#beforeafter-why-this-pattern-matters">Before/After: Why This Pattern Matters</a></li>
<li class="second-level"><a href="#core-implementation">Core Implementation</a></li>
<li class="second-level"><a href="#debugging-challenges">Debugging Challenges</a></li>
<li class="second-level"><a href="#decision-framework">Decision Framework</a></li>
<li class="second-level"><a href="#practice">Practice</a></li>
<li class="second-level"><a href="#review-checklist">Review Checklist</a></li>
</ul>
</div></div>
<div class="col-md-9" role="main">
<h1 id="heaps-priority-queues">Heaps (Priority Queues)<a class="headerlink" href="#heaps-priority-queues" title="Permanent link">¶</a></h1>
<blockquote>
<p>O(log n) insert/delete with O(1) access to min/max element</p>
</blockquote>
<hr/>
<h2 id="eli5-explain-like-im-5">ELI5: Explain Like I'm 5<a class="headerlink" href="#eli5-explain-like-im-5" title="Permanent link">¶</a></h2>
<div class="learner-section">
<p><strong>Your task:</strong> After implementing all patterns, explain them simply.</p>
<p><strong>Prompts to guide you:</strong></p>
<ol>
<li>
<p><strong>What is a heap in one sentence?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after implementation]</span></li>
</ul>
</li>
<li>
<p><strong>Why is it called a priority queue?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after implementation]</span></li>
</ul>
</li>
<li>
<p><strong>Real-world analogy:</strong></p>
<ul>
<li>Example: "A heap is like a hospital emergency room where patients are seen by urgency..."</li>
<li>Your analogy: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li>
<p><strong>When does this pattern work?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after solving problems]</span></li>
</ul>
</li>
<li>
<p><strong>What's the difference between min-heap and max-heap?</strong></p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in after implementation]</span></li>
</ul>
</li>
</ol>
</div>
<hr/>
<h2 id="quick-quiz-do-before-implementing">Quick Quiz (Do BEFORE implementing)<a class="headerlink" href="#quick-quiz-do-before-implementing" title="Permanent link">¶</a></h2>
<div class="learner-section">
<p><strong>Your task:</strong> Test your intuition without looking at code. Answer these, then verify after implementation.</p>
<h3 id="complexity-predictions">Complexity Predictions<a class="headerlink" href="#complexity-predictions" title="Permanent link">¶</a></h3>
<ol>
<li>
<p><strong>Finding Kth largest using sorting:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Verified after learning: <span class="fill-in">[Actual: O(?)]</span></li>
</ul>
</li>
<li>
<p><strong>Finding Kth largest using min-heap of size K:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Space complexity: <span class="fill-in">[Your guess: O(?)]</span></li>
<li>Verified: <span class="fill-in">[Actual]</span></li>
</ul>
</li>
<li>
<p><strong>Efficiency calculation:</strong></p>
<ul>
<li>If n = 100,000 and k = 10, sorting = n log n = <span class="fill-in">_____</span> operations</li>
<li>Heap approach = n log k = <span class="fill-in">_____</span> operations</li>
<li>Speedup factor: approximately _____ times faster</li>
</ul>
</li>
</ol>
<h3 id="scenario-predictions">Scenario Predictions<a class="headerlink" href="#scenario-predictions" title="Permanent link">¶</a></h3>
<p><strong>Scenario 1:</strong> Find 3rd largest in <code>[3, 2, 1, 5, 6, 4]</code></p>
<ul>
<li><strong>Using min-heap of size 3:</strong><ul>
<li>Which elements end up in the heap? <span class="fill-in">[Fill in]</span></li>
<li>What is at the top of the heap? <span class="fill-in">[Fill in - is this the answer?]</span></li>
<li>Why min-heap instead of max-heap? <span class="fill-in">[Fill in your reasoning]</span></li>
</ul>
</li>
</ul>
<p><strong>Scenario 2:</strong> Find median of stream <code>[5, 15, 1, 3]</code></p>
<ul>
<li><strong>Using two heaps:</strong><ul>
<li>After adding 5: maxHeap = <span class="fill-in"><strong><em></em></strong></span>, minHeap = <span class="fill-in"></span>,
  median = <span class="fill-in">___</span></li>
<li>After adding 15: maxHeap = <span class="fill-in"><strong><em></em></strong></span>, minHeap = <span class="fill-in"></span>,
  median = <span class="fill-in">___</span></li>
<li>After adding 1: maxHeap = <span class="fill-in"><strong><em></em></strong></span>, minHeap = <span class="fill-in"></span>,
  median = <span class="fill-in">___</span></li>
<li>After adding 3: maxHeap = <span class="fill-in"><strong><em></em></strong></span>, minHeap = <span class="fill-in"></span>,
  median = <span class="fill-in">___</span></li>
</ul>
</li>
</ul>
<p><strong>Scenario 3:</strong> Merge 3 sorted lists: <code>[1,4,5]</code>, <code>[1,3,4]</code>, <code>[2,6]</code></p>
<ul>
<li><strong>Heap pattern applies?</strong> <span class="fill-in">[Yes/No - Why?]</span></li>
<li><strong>Initial heap state:</strong> <span class="fill-in">[Which elements start in heap?]</span></li>
<li><strong>After first extraction:</strong> <span class="fill-in">[What gets removed? What gets added?]</span></li>
</ul>
<h3 id="trade-off-quiz">Trade-off Quiz<a class="headerlink" href="#trade-off-quiz" title="Permanent link">¶</a></h3>
<p><strong>Question:</strong> When would sorting be BETTER than heap for finding Kth largest?</p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in before implementation]</span></li>
<li>Verified answer: <span class="fill-in">[Fill in after learning]</span></li>
</ul>
<p><strong>Question:</strong> What's the MAIN advantage of heap over Quick Select for Kth largest?</p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Heap is always faster</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Heap works with data streams</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Heap uses less space</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Heap is easier to implement</li>
</ul>
<p>Verify after implementation: <span class="fill-in">[Which one(s)?]</span></p>
<p><strong>Question:</strong> For finding top K elements, why use heap of size K instead of size N?</p>
<ul>
<li>Your answer: <span class="fill-in">[Fill in reasoning]</span></li>
<li>Verified: <span class="fill-in">[Fill in after implementation]</span></li>
</ul>
</div>
<hr/>
<h2 id="beforeafter-why-this-pattern-matters">Before/After: Why This Pattern Matters<a class="headerlink" href="#beforeafter-why-this-pattern-matters" title="Permanent link">¶</a></h2>
<p><strong>Your task:</strong> Compare naive vs optimized approaches to understand the impact.</p>
<h3 id="example-1-find-kth-largest-element">Example 1: Find Kth Largest Element<a class="headerlink" href="#example-1-find-kth-largest-element" title="Permanent link">¶</a></h3>
<p><strong>Problem:</strong> Find the Kth largest element in an unsorted array.</p>
<h4 id="approach-1-sorting-simple-but-inefficient">Approach 1: Sorting (Simple but Inefficient)<a class="headerlink" href="#approach-1-sorting-simple-but-inefficient" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Naive approach - Sort entire array
public static int findKthLargest_Sorting(int[] nums, int k) {
    Arrays.sort(nums);  // Sort ascending
    return nums[nums.length - k];  // Kth largest
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Time: O(n log n) - Must sort all n elements</li>
<li>Space: O(1) or O(log n) depending on sort algorithm</li>
<li>For n = 100,000: ~1,600,000 operations</li>
</ul>
<h4 id="approach-2-min-heap-of-size-k-optimized">Approach 2: Min-Heap of Size K (Optimized)<a class="headerlink" href="#approach-2-min-heap-of-size-k-optimized" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Optimized approach - Maintain heap of K largest elements
public static int findKthLargest_Heap(int[] nums, int k) {
    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();

    for (int num : nums) {
        minHeap.offer(num);
        if (minHeap.size() &gt; k) {
            minHeap.poll();  // Remove smallest
        }
    }

    return minHeap.peek();  // Kth largest at top
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Time: O(n log k) - n insertions, each log k operations</li>
<li>Space: O(k) - Only store K elements</li>
<li>For n = 100,000, k = 10: ~166,000 operations</li>
</ul>
<h4 id="performance-comparison">Performance Comparison<a class="headerlink" href="#performance-comparison" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Array Size (n)</th>
<th>k</th>
<th>Sorting (O(n log n))</th>
<th>Heap (O(n log k))</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>n = 1,000</td>
<td>10</td>
<td>~10,000 ops</td>
<td>~3,000 ops</td>
<td>3x</td>
</tr>
<tr>
<td>n = 10,000</td>
<td>10</td>
<td>~130,000 ops</td>
<td>~33,000 ops</td>
<td>4x</td>
</tr>
<tr>
<td>n = 100,000</td>
<td>100</td>
<td>~1,600,000 ops</td>
<td>~660,000 ops</td>
<td>2.4x</td>
</tr>
</tbody>
</table>
<p><strong>Your calculation:</strong> For n = 50,000 and k = 50, the speedup is approximately _____ times faster.</p>
<h4 id="why-does-min-heap-work-for-kth-largest">Why Does Min-Heap Work for Kth LARGEST?<a class="headerlink" href="#why-does-min-heap-work-for-kth-largest" title="Permanent link">¶</a></h4>
<p><strong>Key insight to understand:</strong></p>
<p>In array <code>[3, 2, 1, 5, 6, 4]</code> looking for k=2 (2nd largest):</p>
<pre class="highlight"><code>Step 1: Add 3 → Heap: [3]
Step 2: Add 2 → Heap: [2, 3] (size=2)
Step 3: Add 1 → Heap: [2, 3], size &gt; k → remove min → Heap: [3]
Step 4: Add 5 → Heap: [3, 5]
Step 5: Add 6 → Heap: [3, 5], size &gt; k → remove min → Heap: [5, 6]
Step 6: Add 4 → Heap: [4, 5, 6], remove min → Heap: [5, 6]

Answer: heap.peek() = 5 (2nd largest)</code></pre>
<p><strong>Why min-heap, not max-heap?</strong></p>
<ul>
<li>Min-heap keeps K largest elements, smallest of them at top</li>
<li>When heap size exceeds K, we remove the SMALLEST of the K largest</li>
<li>The top element is the Kth largest!</li>
</ul>
<p><strong>After implementing, explain in your own words:</strong></p>
<div class="learner-section">
<ul>
<li>Why does removing the minimum preserve the K largest elements? <span class="fill-in">[Your answer]</span></li>
<li>What would happen with a max-heap instead? <span class="fill-in">[Your answer]</span></li>
</ul>
</div>
<hr/>
<h3 id="example-2-finding-running-median">Example 2: Finding Running Median<a class="headerlink" href="#example-2-finding-running-median" title="Permanent link">¶</a></h3>
<p><strong>Problem:</strong> Maintain the median as numbers are added one by one.</p>
<h4 id="approach-1-sort-every-time-inefficient">Approach 1: Sort Every Time (Inefficient)<a class="headerlink" href="#approach-1-sort-every-time-inefficient" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Naive approach - Re-sort after each insertion
public static class MedianFinder_Sorting {
    private List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    public void addNum(int num) {
        list.add(num);
        Collections.sort(list);  // Re-sort entire list!
    }

    public double findMedian() {
        int n = list.size();
        if (n % 2 == 1) {
            return list.get(n / 2);
        } else {
            return (list.get(n / 2 - 1) + list.get(n / 2)) / 2.0;
        }
    }
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Time: O(n log n) per insertion due to sorting</li>
<li>Space: O(n)</li>
<li>For 10,000 insertions: ~100,000,000 total operations</li>
</ul>
<h4 id="approach-2-two-heaps-optimized">Approach 2: Two Heaps (Optimized)<a class="headerlink" href="#approach-2-two-heaps-optimized" title="Permanent link">¶</a></h4>
<pre class="highlight"><code class="language-java">// Optimized approach - Two heaps maintain balance
public static class MedianFinder_TwoHeaps {
    private PriorityQueue&lt;Integer&gt; maxHeap;  // Smaller half
    private PriorityQueue&lt;Integer&gt; minHeap;  // Larger half

    public MedianFinder_TwoHeaps() {
        maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());
        minHeap = new PriorityQueue&lt;&gt;();
    }

    public void addNum(int num) {
        maxHeap.offer(num);
        minHeap.offer(maxHeap.poll());

        if (maxHeap.size() &lt; minHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        if (maxHeap.size() &gt; minHeap.size()) {
            return maxHeap.peek();
        }
        return (maxHeap.peek() + minHeap.peek()) / 2.0;
    }
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>Time: O(log n) per insertion</li>
<li>Space: O(n)</li>
<li>For 10,000 insertions: ~130,000 total operations</li>
</ul>
<h4 id="performance-comparison_1">Performance Comparison<a class="headerlink" href="#performance-comparison_1" title="Permanent link">¶</a></h4>
<table>
<thead>
<tr>
<th>Number of Elements</th>
<th>Sorting (O(n²log n) total)</th>
<th>Two Heaps (O(n log n) total)</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>n = 100</td>
<td>~66,000 ops</td>
<td>~700 ops</td>
<td>94x</td>
</tr>
<tr>
<td>n = 1,000</td>
<td>~10,000,000 ops</td>
<td>~10,000 ops</td>
<td>1,000x</td>
</tr>
<tr>
<td>n = 10,000</td>
<td>~1,300,000,000 ops</td>
<td>~130,000 ops</td>
<td>10,000x</td>
</tr>
</tbody>
</table>
<p><strong>Your calculation:</strong> For n = 5,000 elements, the speedup is approximately _____ times faster.</p>
<h4 id="why-do-two-heaps-work">Why Do Two Heaps Work?<a class="headerlink" href="#why-do-two-heaps-work" title="Permanent link">¶</a></h4>
<p><strong>Key insight:</strong></p>
<pre class="highlight"><code>Stream: [5, 15, 1, 3]

Add 5:  maxHeap=[5], minHeap=[] → Median = 5
Add 15: maxHeap=[5], minHeap=[15] → Median = (5+15)/2 = 10
Add 1:  maxHeap=[5,1], minHeap=[15] → Median = 5
Add 3:  maxHeap=[5,3,1], minHeap=[15] → rebalance → maxHeap=[5,3], minHeap=[15]
        → Median = (5+15)/2 = 10</code></pre>
<p><strong>Invariant maintained:</strong></p>
<ul>
<li>maxHeap contains smaller half (max element on top)</li>
<li>minHeap contains larger half (min element on top)</li>
<li>Size difference ≤ 1</li>
<li>Median is at the top(s)!</li>
</ul>
<p><strong>After implementing, explain in your own words:</strong></p>
<div class="learner-section">
<ul>
<li>Why do we need both heaps instead of just sorting? <span class="fill-in">[Your answer]</span></li>
<li>How does keeping them balanced help find median quickly? <span class="fill-in">[Your answer]</span></li>
</ul>
</div>
<hr/>
<h2 id="core-implementation">Core Implementation<a class="headerlink" href="#core-implementation" title="Permanent link">¶</a></h2>
<h3 id="pattern-1-basic-heap-operations">Pattern 1: Basic Heap Operations<a class="headerlink" href="#pattern-1-basic-heap-operations" title="Permanent link">¶</a></h3>
<p><strong>Concept:</strong> Maintain heap property through insert and extract operations.</p>
<p><strong>Use case:</strong> Find kth largest/smallest, top K elements.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class BasicHeapOperations {

    /**
     * Problem: Find Kth largest element in array
     * Time: O(n log k), Space: O(k)
     *
     * TODO: Implement using min-heap of size k
     */
    public static int findKthLargest(int[] nums, int k) {
        // TODO: Create PriorityQueue (min-heap) of size k
        // TODO: Implement iteration/conditional logic
        // TODO: Return heap.peek() (kth largest)

        return 0; // Replace with implementation
    }

    /**
     * Problem: Find K largest elements
     * Time: O(n log k), Space: O(k)
     *
     * TODO: Implement K largest elements
     */
    public static List&lt;Integer&gt; kLargest(int[] nums, int k) {
        // TODO: Use min-heap of size k
        // TODO: Maintain k largest elements
        // TODO: Return heap as list

        return new ArrayList&lt;&gt;(); // Replace with implementation
    }

    /**
     * Problem: Sort array using heap
     * Time: O(n log n), Space: O(n)
     *
     * TODO: Implement heap sort
     */
    public static int[] heapSort(int[] nums) {
        // TODO: Add all elements to max-heap
        // TODO: Extract max repeatedly to get sorted array

        return new int[0]; // Replace with implementation
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class BasicHeapOperationsClient {

    public static void main(String[] args) {
        System.out.println("=== Basic Heap Operations ===\n");

        // Test 1: Kth largest
        System.out.println("--- Test 1: Kth Largest ---");
        int[] arr = {3, 2, 1, 5, 6, 4};
        int k = 2;

        System.out.println("Array: " + Arrays.toString(arr));
        System.out.println("k = " + k);
        int kthLargest = BasicHeapOperations.findKthLargest(arr, k);
        System.out.println("Kth largest: " + kthLargest);

        // Test 2: K largest elements
        System.out.println("\n--- Test 2: K Largest Elements ---");
        int[] arr2 = {3, 2, 3, 1, 2, 4, 5, 5, 6};
        k = 4;

        System.out.println("Array: " + Arrays.toString(arr2));
        System.out.println("k = " + k);
        List&lt;Integer&gt; kLargest = BasicHeapOperations.kLargest(arr2, k);
        System.out.println("K largest: " + kLargest);

        // Test 3: Heap sort
        System.out.println("\n--- Test 3: Heap Sort ---");
        int[] arr3 = {5, 2, 8, 1, 9, 3};
        System.out.println("Before: " + Arrays.toString(arr3));
        int[] sorted = BasicHeapOperations.heapSort(arr3);
        System.out.println("After:  " + Arrays.toString(sorted));
    }
}</code></pre>
<hr/>
<h3 id="pattern-2-merge-k-sorted-listsarrays">Pattern 2: Merge K Sorted Lists/Arrays<a class="headerlink" href="#pattern-2-merge-k-sorted-listsarrays" title="Permanent link">¶</a></h3>
<p><strong>Concept:</strong> Use min-heap to merge multiple sorted sequences efficiently.</p>
<p><strong>Use case:</strong> Merge K sorted lists, merge K sorted arrays.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class MergeKSorted {

    static class ListNode {
        int val;
        ListNode next;

        ListNode(int val) {
            this.val = val;
        }
    }

    /**
     * Problem: Merge K sorted linked lists
     * Time: O(n log k), Space: O(k) where n = total nodes, k = lists
     *
     * TODO: Implement using min-heap
     */
    public static ListNode mergeKLists(ListNode[] lists) {
        // TODO: Create min-heap with comparator on node.val
        // TODO: Add first node from each list to heap
        // TODO: Implement iteration/conditional logic

        return null; // Replace with implementation
    }

    /**
     * Problem: Merge K sorted arrays
     * Time: O(n log k), Space: O(k)
     *
     * TODO: Implement using min-heap with array indices
     */
    public static List&lt;Integer&gt; mergeKArrays(int[][] arrays) {
        // TODO: Create heap with [value, arrayIndex, elementIndex]
        // TODO: Add first element from each array
        // TODO: Extract min and add next from same array

        return new ArrayList&lt;&gt;(); // Replace with implementation
    }

    /**
     * Problem: Find smallest range covering elements from K lists
     * Time: O(n log k), Space: O(k)
     *
     * TODO: Implement using heap tracking max
     */
    public static int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) {
        // TODO: Use min-heap, track current max
        // TODO: Range = [heap.peek(), currentMax]
        // TODO: Minimize range size

        return new int[]{0, 0}; // Replace with implementation
    }

    // Helper: Create linked list from array
    static ListNode createList(int[] values) {
        if (values.length == 0) return null;
        ListNode head = new ListNode(values[0]);
        ListNode current = head;
        for (int i = 1; i &lt; values.length; i++) {
            current.next = new ListNode(values[i]);
            current = current.next;
        }
        return head;
    }

    // Helper: Print linked list
    static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val);
            if (current.next != null) System.out.print(" -&gt; ");
            current = current.next;
        }
        System.out.println();
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class MergeKSortedClient {

    public static void main(String[] args) {
        System.out.println("=== Merge K Sorted ===\n");

        // Test 1: Merge K lists
        System.out.println("--- Test 1: Merge K Linked Lists ---");
        ListNode[] lists = new ListNode[3];
        lists[0] = MergeKSorted.createList(new int[]{1, 4, 5});
        lists[1] = MergeKSorted.createList(new int[]{1, 3, 4});
        lists[2] = MergeKSorted.createList(new int[]{2, 6});

        System.out.println("List 1: ");
        MergeKSorted.printList(lists[0]);
        System.out.println("List 2: ");
        MergeKSorted.printList(lists[1]);
        System.out.println("List 3: ");
        MergeKSorted.printList(lists[2]);

        ListNode merged = MergeKSorted.mergeKLists(lists);
        System.out.print("Merged: ");
        MergeKSorted.printList(merged);

        // Test 2: Merge K arrays
        System.out.println("\n--- Test 2: Merge K Arrays ---");
        int[][] arrays = {
            {1, 3, 5, 7},
            {2, 4, 6, 8},
            {0, 9, 10, 11}
        };

        for (int i = 0; i &lt; arrays.length; i++) {
            System.out.println("Array " + (i + 1) + ": " + Arrays.toString(arrays[i]));
        }

        List&lt;Integer&gt; mergedArray = MergeKSorted.mergeKArrays(arrays);
        System.out.println("Merged: " + mergedArray);

        // Test 3: Smallest range
        System.out.println("\n--- Test 3: Smallest Range ---");
        List&lt;List&lt;Integer&gt;&gt; nums = Arrays.asList(
            Arrays.asList(4, 10, 15, 24, 26),
            Arrays.asList(0, 9, 12, 20),
            Arrays.asList(5, 18, 22, 30)
        );

        System.out.println("Lists: " + nums);
        int[] range = MergeKSorted.smallestRange(nums);
        System.out.println("Smallest range: [" + range[0] + ", " + range[1] + "]");
    }
}</code></pre>
<hr/>
<h3 id="pattern-3-top-k-frequent-elements">Pattern 3: Top K Frequent Elements<a class="headerlink" href="#pattern-3-top-k-frequent-elements" title="Permanent link">¶</a></h3>
<p><strong>Concept:</strong> Use heap to find most/least frequent elements.</p>
<p><strong>Use case:</strong> Top K frequent elements, sort by frequency.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class TopKFrequent {

    /**
     * Problem: Find K most frequent elements
     * Time: O(n log k), Space: O(n)
     *
     * TODO: Implement using frequency map + min-heap
     */
    public static List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        // TODO: Count frequencies with HashMap
        // TODO: Create min-heap of size k, ordered by frequency
        // TODO: Implement iteration/conditional logic
        // TODO: Return heap contents

        return new ArrayList&lt;&gt;(); // Replace with implementation
    }

    /**
     * Problem: Sort array by frequency
     * Time: O(n log n), Space: O(n)
     *
     * TODO: Implement frequency sort
     */
    public static int[] frequencySort(int[] nums) {
        // TODO: Count frequencies
        // TODO: Sort by frequency (descending), then by value (ascending)

        return new int[0]; // Replace with implementation
    }

    /**
     * Problem: K closest points to origin
     * Time: O(n log k), Space: O(k)
     *
     * TODO: Implement using max-heap of size k
     */
    public static int[][] kClosest(int[][] points, int k) {
        // TODO: Create max-heap ordered by distance
        // TODO: Maintain k closest points
        // TODO: Distance = x^2 + y^2 (no need for sqrt)

        return new int[0][0]; // Replace with implementation
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class TopKFrequentClient {

    public static void main(String[] args) {
        System.out.println("=== Top K Frequent ===\n");

        // Test 1: Top K frequent
        System.out.println("--- Test 1: Top K Frequent ---");
        int[] arr = {1, 1, 1, 2, 2, 3};
        int k = 2;

        System.out.println("Array: " + Arrays.toString(arr));
        System.out.println("k = " + k);
        List&lt;Integer&gt; topK = TopKFrequent.topKFrequent(arr, k);
        System.out.println("Top K frequent: " + topK);

        // Test 2: Frequency sort
        System.out.println("\n--- Test 2: Frequency Sort ---");
        int[] arr2 = {1, 1, 2, 2, 2, 3};
        System.out.println("Before: " + Arrays.toString(arr2));
        int[] sorted = TopKFrequent.frequencySort(arr2);
        System.out.println("After:  " + Arrays.toString(sorted));

        // Test 3: K closest points
        System.out.println("\n--- Test 3: K Closest Points ---");
        int[][] points = {{1, 3}, {-2, 2}, {5, 8}, {0, 1}};
        k = 2;

        System.out.println("Points:");
        for (int[] point : points) {
            System.out.println("  " + Arrays.toString(point));
        }
        System.out.println("k = " + k);

        int[][] closest = TopKFrequent.kClosest(points, k);
        System.out.println("K closest points:");
        for (int[] point : closest) {
            System.out.println("  " + Arrays.toString(point));
        }
    }
}</code></pre>
<hr/>
<h3 id="pattern-4-two-heaps-find-median">Pattern 4: Two Heaps (Find Median)<a class="headerlink" href="#pattern-4-two-heaps-find-median" title="Permanent link">¶</a></h3>
<p><strong>Concept:</strong> Use two heaps to maintain running median.</p>
<p><strong>Use case:</strong> Find median from data stream, sliding window median.</p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class TwoHeaps {

    /**
     * MedianFinder: Maintain running median
     * Time: O(log n) insert, O(1) find median
     * Space: O(n)
     *
     * TODO: Implement using two heaps
     */
    static class MedianFinder {
        // TODO: maxHeap stores smaller half (max at top)
        // TODO: minHeap stores larger half (min at top)
        // TODO: Keep heaps balanced: |size difference| &lt;= 1

        public MedianFinder() {
            // TODO: Initialize PriorityQueue for max-heap (reverse order)
            // TODO: Initialize PriorityQueue for min-heap (natural order)
        }

        public void addNum(int num) {
            // TODO: Add to appropriate heap
            // TODO: Balance heaps if needed
            // Hint: Always add to maxHeap first, then move to minHeap if needed
        }

        public double findMedian() {
            // TODO: Implement iteration/conditional logic
            // TODO: Implement iteration/conditional logic
            return 0.0; // Replace with implementation
        }
    }

    /**
     * Problem: Sliding window median
     * Time: O(n * k), Space: O(k)
     *
     * TODO: Implement sliding window median
     */
    public static double[] medianSlidingWindow(int[] nums, int k) {
        // TODO: Use two heaps approach
        // TODO: Handle removal from window
        // Note: This is complex - use TreeMap or simpler approach

        return new double[0]; // Replace with implementation
    }
}</code></pre>
<p><strong>Runnable Client Code:</strong></p>
<pre class="highlight"><code class="language-java">import java.util.*;

public class TwoHeapsClient {

    public static void main(String[] args) {
        System.out.println("=== Two Heaps ===\n");

        // Test 1: Median finder
        System.out.println("--- Test 1: Find Median from Data Stream ---");
        TwoHeaps.MedianFinder mf = new TwoHeaps.MedianFinder();

        int[] stream = {1, 2, 3, 4, 5};
        System.out.println("Data stream: " + Arrays.toString(stream));
        System.out.println("Median after each insertion:");

        for (int num : stream) {
            mf.addNum(num);
            System.out.printf("  After adding %d: %.1f%n", num, mf.findMedian());
        }

        // Test 2: Another stream
        System.out.println("\n--- Test 2: Another Stream ---");
        TwoHeaps.MedianFinder mf2 = new TwoHeaps.MedianFinder();
        int[] stream2 = {5, 15, 1, 3};

        System.out.println("Data stream: " + Arrays.toString(stream2));
        System.out.println("Median after each insertion:");

        for (int num : stream2) {
            mf2.addNum(num);
            System.out.printf("  After adding %d: %.1f%n", num, mf2.findMedian());
        }

        // Test 3: Sliding window median
        System.out.println("\n--- Test 3: Sliding Window Median ---");
        int[] arr = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;

        System.out.println("Array: " + Arrays.toString(arr));
        System.out.println("Window size: " + k);
        double[] medians = TwoHeaps.medianSlidingWindow(arr, k);
        System.out.println("Medians: " + Arrays.toString(medians));
    }
}</code></pre>
<hr/>
<h2 id="debugging-challenges">Debugging Challenges<a class="headerlink" href="#debugging-challenges" title="Permanent link">¶</a></h2>
<p><strong>Your task:</strong> Find and fix bugs in broken heap implementations. This tests your understanding.</p>
<h3 id="challenge-1-broken-kth-largest-finder">Challenge 1: Broken Kth Largest Finder<a class="headerlink" href="#challenge-1-broken-kth-largest-finder" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * This code is supposed to find the Kth largest element.
 * It has 2 BUGS. Find them!
 */
public static int findKthLargest_Buggy(int[] nums, int k) {
    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(
        Collections.reverseOrder()    );

    for (int num : nums) {
        maxHeap.offer(num);
        if (maxHeap.size() &gt; k) {
            maxHeap.poll();        }
    }

    return maxHeap.peek();
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li>
<p>Bug 1: <span class="fill-in">[What\'s the bug?]</span></p>
</li>
<li>
<p><strong>Bug 2 location:</strong> <span class="fill-in">[Which line?]</span></p>
</li>
<li><strong>Bug 2 explanation:</strong> <span class="fill-in">[What gets removed? Is this what we want?]</span></li>
<li><strong>Bug 2 impact:</strong> <span class="fill-in">[What will the final answer be?]</span></li>
</ul>
<p><strong>Test case to expose the bug:</strong></p>
<ul>
<li>Input: <code>nums = [3, 2, 1, 5, 6, 4]</code>, <code>k = 2</code></li>
<li>Expected: <code>5</code> (2nd largest)</li>
<li>Actual with buggy code: <span class="fill-in">[Trace through manually]</span></li>
</ul>
<details>
<summary>Click to verify your answers</summary>
<p><strong>Bug 1:</strong> Should use <strong>min-heap</strong>, not max-heap! For Kth largest, we want to keep the K largest elements and remove the
smallest among them.</p>
<p><strong>Correct:</strong></p>
<pre class="highlight"><code class="language-java">PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();</code></pre>
<p><strong>Bug 2:</strong> With max-heap, <code>poll()</code> removes the LARGEST element, which is exactly what we want to KEEP! This defeats the
purpose.</p>
<p><strong>Why min-heap works:</strong></p>
<ul>
<li>Min-heap of size K keeps K largest elements</li>
<li>The smallest of these K largest is at the top</li>
<li>That smallest element IS the Kth largest!</li>
</ul>
<p><strong>Trace with correct code:</strong></p>
<pre class="highlight"><code>[3, 2, 1, 5, 6, 4], k=2
Add 3: [3]
Add 2: [2,3]
Add 1: [1,2,3], size&gt;2, poll() removes 1 → [2,3]
Add 5: [2,3,5], poll() removes 2 → [3,5]
Add 6: [3,5,6], poll() removes 3 → [5,6]
Add 4: [4,5,6], poll() removes 4 → [5,6]
peek() = 5 ✓</code></pre>
</details>
<hr/>
<h3 id="challenge-2-broken-two-heap-median-finder">Challenge 2: Broken Two-Heap Median Finder<a class="headerlink" href="#challenge-2-broken-two-heap-median-finder" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * Find median from data stream using two heaps.
 * This has 2 CRITICAL BUGS.
 */
static class MedianFinder_Buggy {
    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder());
    PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();

    public void addNum(int num) {
        if (maxHeap.isEmpty() || num &lt; maxHeap.peek()) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
    }

    public double findMedian() {
        if (maxHeap.size() &gt; minHeap.size()) {
            return maxHeap.peek();
        } else if (minHeap.size() &gt; maxHeap.size()) {
            return minHeap.peek();        } else {
            return (maxHeap.peek() + minHeap.peek()) / 2;
        }
    }
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li><strong>Bug 1:</strong> <span class="fill-in">[What's missing after adding elements?]</span></li>
<li><strong>Bug 1 explanation:</strong> <span class="fill-in">[What happens if sizes become unbalanced?]</span></li>
<li>
<p><strong>Bug 1 fix:</strong> <span class="fill-in">[What code should be added?]</span></p>
</li>
<li>
<p><strong>Bug 2:</strong> <span class="fill-in">[Which heap should contain the median for even split?]</span></p>
</li>
<li><strong>Bug 2 explanation:</strong> <span class="fill-in">[Trace through example: add 1, 2, 3]</span></li>
<li><strong>Bug 2 fix:</strong> <span class="fill-in">[Fill in]</span></li>
</ul>
<p><strong>Test case:</strong></p>
<ul>
<li>Stream: <code>[1, 2, 3, 4, 5]</code></li>
<li>Expected medians: <code>[1.0, 1.5, 2.0, 2.5, 3.0]</code></li>
<li>Actual with buggy code: <span class="fill-in">[Trace through]</span></li>
</ul>
<details>
<summary>Click to verify your answers</summary>
<p><strong>Bug 1:</strong> Missing <strong>rebalancing logic</strong>! Heaps can become severely unbalanced.</p>
<p><strong>Correct addNum:</strong></p>
<pre class="highlight"><code class="language-java">public void addNum(int num) {
    if (maxHeap.isEmpty() || num &lt; maxHeap.peek()) {
        maxHeap.offer(num);
    } else {
        minHeap.offer(num);
    }

    // REBALANCE - maintain size difference ≤ 1
    if (maxHeap.size() &gt; minHeap.size() + 1) {
        minHeap.offer(maxHeap.poll());
    } else if (minHeap.size() &gt; maxHeap.size()) {
        maxHeap.offer(minHeap.poll());
    }
}</code></pre>
<p><strong>Bug 2:</strong> The else-if case should probably never happen if we maintain maxHeap.size() &gt;= minHeap.size() as invariant.
But if it does, the logic is actually correct - we'd return minHeap.peek().</p>
<p><strong>Better approach - Always add to maxHeap first:</strong></p>
<pre class="highlight"><code class="language-java">public void addNum(int num) {
    maxHeap.offer(num);
    minHeap.offer(maxHeap.poll());

    if (maxHeap.size() &lt; minHeap.size()) {
        maxHeap.offer(minHeap.poll());
    }
}</code></pre>
<p>This ensures maxHeap.size() is always &gt;= minHeap.size().</p>
</details>
<hr/>
<h3 id="challenge-3-heap-index-calculation-bugs">Challenge 3: Heap Index Calculation Bugs<a class="headerlink" href="#challenge-3-heap-index-calculation-bugs" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * Manual heap implementation with parent/child index calculations.
 * This has INDEX CALCULATION BUGS.
 */
static class MinHeap_Buggy {
    private List&lt;Integer&gt; heap = new ArrayList&lt;&gt;();

    private int parent(int i) {
        return i / 2;    }

    private int leftChild(int i) {
        return 2 * i;    }

    private int rightChild(int i) {
        return 2 * i + 1;    }

    public void insert(int val) {
        heap.add(val);
        heapifyUp(heap.size() - 1);
    }

    private void heapifyUp(int i) {
        while (i &gt; 0 &amp;&amp; heap.get(i) &lt; heap.get(parent(i))) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    private void swap(int i, int j) {
        int temp = heap.get(i);
        heap.set(i, heap.get(j));
        heap.set(j, temp);
    }
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li><strong>Bug 1:</strong> <span class="fill-in">[What's the correct parent formula for 0-indexed array?]</span></li>
<li><strong>Bug 2:</strong> <span class="fill-in">[What's the correct leftChild formula?]</span></li>
<li><strong>Bug 3:</strong> <span class="fill-in">[What's the correct rightChild formula?]</span></li>
</ul>
<p><strong>Heap index formulas:</strong></p>
<ul>
<li>For 0-indexed array:<ul>
<li>Parent of i: <span class="fill-in">[Your formula]</span></li>
<li>Left child of i: <span class="fill-in">[Your formula]</span></li>
<li>Right child of i: <span class="fill-in">[Your formula]</span></li>
</ul>
</li>
</ul>
<p><strong>Test case:</strong></p>
<pre class="highlight"><code>Insert: 5, 3, 7, 1
Expected heap array: [1, 3, 7, 5] (min-heap property)
Actual with buggy code: &lt;span class="fill-in"&gt;[What happens?]&lt;/span&gt;</code></pre>
<details>
<summary>Click to verify your answers</summary>
<p><strong>All three formulas are wrong for 0-indexed arrays!</strong></p>
<p><strong>Correct formulas for 0-indexed:</strong></p>
<pre class="highlight"><code class="language-java">private int parent(int i) {
    return (i - 1) / 2;  // Not i / 2
}

private int leftChild(int i) {
    return 2 * i + 1;  // Not 2 * i
}

private int rightChild(int i) {
    return 2 * i + 2;  // Not 2 * i + 1
}</code></pre>
<p><strong>Why these formulas?</strong></p>
<p>In 0-indexed array <code>[0, 1, 2, 3, 4, 5, 6]</code>:</p>
<pre class="highlight"><code>       0
      / \
     1   2
    / \ / \
   3  4 5  6</code></pre>
<ul>
<li>Parent of 1: (1-1)/2 = 0 ✓</li>
<li>Parent of 2: (2-1)/2 = 0 ✓</li>
<li>Left of 0: 2*0+1 = 1 ✓</li>
<li>Right of 0: 2*0+2 = 2 ✓</li>
<li>Left of 1: 2*1+1 = 3 ✓</li>
<li>Right of 1: 2*1+2 = 4 ✓</li>
</ul>
<p><strong>For 1-indexed arrays (if you stored heap starting at index 1):</strong></p>
<pre class="highlight"><code class="language-java">parent(i) = i / 2
leftChild(i) = 2 * i
rightChild(i) = 2 * i + 1</code></pre>
<p>This is why some people prefer 1-indexed - simpler formulas!</p>
</details>
<hr/>
<h3 id="challenge-4-min-heap-vs-max-heap-confusion">Challenge 4: Min-Heap vs Max-Heap Confusion<a class="headerlink" href="#challenge-4-min-heap-vs-max-heap-confusion" title="Permanent link">¶</a></h3>
<pre class="highlight"><code class="language-java">/**
 * Find K closest points to origin.
 * This code has HEAP TYPE BUG.
 */
public static int[][] kClosest_Buggy(int[][] points, int k) {
    PriorityQueue&lt;int[]&gt; minHeap = new PriorityQueue&lt;&gt;(
        (a, b) -&gt; (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1])
    );
    for (int[] point : points) {
        minHeap.offer(point);
        if (minHeap.size() &gt; k) {
            minHeap.poll();
        }
    }

    int[][] result = new int[k][2];
    for (int i = 0; i &lt; k; i++) {
        result[i] = minHeap.poll();
    }
    return result;
}</code></pre>
<p><strong>Your debugging:</strong></p>
<ul>
<li>Bug: <span class="fill-in">[What\'s the bug?]</span></li>
</ul>
<p><strong>Think about it:</strong></p>
<ul>
<li>For K largest → Use <span class="fill-in">[min/max]</span>-heap</li>
<li>For K smallest → Use <span class="fill-in">[min/max]</span>-heap</li>
<li>For K closest → Same as K <span class="fill-in">[largest/smallest]</span> distances</li>
<li>Therefore, use <span class="fill-in">[min/max]</span>-heap</li>
</ul>
<p><strong>Test case:</strong></p>
<pre class="highlight"><code>Points: [[1,3], [-2,2], [5,8], [0,1]], k=2
Distances: [10, 8, 89, 1]
Expected: [[0,1], [-2,2]] (distances 1 and 8)
Actual with buggy code: &lt;span class="fill-in"&gt;[What do you get?]&lt;/span&gt;</code></pre>
<details>
<summary>Click to verify your answers</summary>
<p><strong>Bug:</strong> Using min-heap is WRONG! We need <strong>max-heap</strong>.</p>
<p><strong>Why?</strong></p>
<ul>
<li>K closest = K smallest distances</li>
<li>For K smallest distances, use max-heap (same logic as Kth largest)</li>
<li>Keep K smallest, remove the largest of them when heap exceeds size K</li>
</ul>
<p><strong>Correct:</strong></p>
<pre class="highlight"><code class="language-java">PriorityQueue&lt;int[]&gt; maxHeap = new PriorityQueue&lt;&gt;(
    (a, b) -&gt; (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])
    // Note: b - a for max-heap (reverse comparison)
);</code></pre>
<p><strong>Pattern to remember:</strong></p>
<ul>
<li><strong>K largest values</strong> → min-heap of size K (remove smallest)</li>
<li><strong>K smallest values</strong> → max-heap of size K (remove largest)</li>
</ul>
<p>This seems backwards but makes sense: you want to remove the "outlier" from your K elements!</p>
</details>
<hr/>
<h3 id="your-debugging-scorecard">Your Debugging Scorecard<a class="headerlink" href="#your-debugging-scorecard" title="Permanent link">¶</a></h3>
<p>After finding and fixing all bugs:</p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Found all bugs in Kth largest (min vs max heap)</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Found rebalancing bug in median finder</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Fixed all three index calculation formulas</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understood when to use min-heap vs max-heap</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could explain WHY each bug causes incorrect behavior</li>
</ul>
<p><strong>Common heap mistakes you discovered:</strong></p>
<ol>
<li><span class="fill-in">[Min vs max confusion - when to use which?]</span></li>
<li><span class="fill-in">[Index calculation errors in manual implementation]</span></li>
<li><span class="fill-in">[Forgetting to rebalance in two-heap pattern]</span></li>
<li><span class="fill-in">[Fill in - what other patterns did you notice?]</span></li>
</ol>
<hr/>
<h2 id="decision-framework">Decision Framework<a class="headerlink" href="#decision-framework" title="Permanent link">¶</a></h2>
<p><strong>Your task:</strong> Build decision trees for when to use heaps.</p>
<h3 id="question-1-what-do-you-need-to-track">Question 1: What do you need to track?<a class="headerlink" href="#question-1-what-do-you-need-to-track" title="Permanent link">¶</a></h3>
<p>Answer after solving problems:</p>
<ul>
<li><strong>Need min/max element repeatedly?</strong> <span class="fill-in">[Use heap]</span></li>
<li><strong>Need Kth largest/smallest?</strong> <span class="fill-in">[Use heap of size K]</span></li>
<li><strong>Need median?</strong> <span class="fill-in">[Use two heaps]</span></li>
<li><strong>Your observation:</strong> <span class="fill-in">[Fill in based on testing]</span></li>
</ul>
<h3 id="question-2-what-are-the-timespace-trade-offs">Question 2: What are the time/space trade-offs?<a class="headerlink" href="#question-2-what-are-the-timespace-trade-offs" title="Permanent link">¶</a></h3>
<p>Answer for each pattern:</p>
<p><strong>Basic heap operations:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Insert? Extract? Peek?]</span></li>
<li>Space complexity: <span class="fill-in">[How much space?]</span></li>
<li>Best use cases: <span class="fill-in">[List problems you solved]</span></li>
</ul>
<p><strong>Merge K sorted:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Compare to merge two at a time]</span></li>
<li>Space complexity: <span class="fill-in">[Just heap or output too?]</span></li>
<li>Best use cases: <span class="fill-in">[List problems you solved]</span></li>
</ul>
<p><strong>Top K frequent:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Why log k not log n?]</span></li>
<li>Space complexity: <span class="fill-in">[Frequency map + heap]</span></li>
<li>Best use cases: <span class="fill-in">[List problems you solved]</span></li>
</ul>
<p><strong>Two heaps:</strong></p>
<ul>
<li>Time complexity: <span class="fill-in">[Insert? Find median?]</span></li>
<li>Space complexity: <span class="fill-in">[Both heaps needed?]</span></li>
<li>Best use cases: <span class="fill-in">[List problems you solved]</span></li>
</ul>
<h3 id="your-decision-tree">Your Decision Tree<a class="headerlink" href="#your-decision-tree" title="Permanent link">¶</a></h3>
<p>Build this after solving practice problems:
<div class="mermaid">flowchart LR
    Start["Heap Pattern Selection"]

    Q1{"Need Kth largest/smallest?"}
    Start --&gt; Q1
    Q2{"Merge K sorted sequences?"}
    Start --&gt; Q2
    Q3{"Need top K frequent?"}
    Start --&gt; Q3
    Q4{"Need running median?"}
    Start --&gt; Q4
    Q5{"Need all elements sorted?"}
    Start --&gt; Q5</div></p>
<hr/>
<h2 id="practice">Practice<a class="headerlink" href="#practice" title="Permanent link">¶</a></h2>
<h3 id="leetcode-problems">LeetCode Problems<a class="headerlink" href="#leetcode-problems" title="Permanent link">¶</a></h3>
<p><strong>Easy (Complete all 3):</strong></p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/">703. Kth Largest Element in a Stream</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Min-heap of size K]</span></li>
<li>Your solution time: <span class="fill-in">___</span></li>
<li>Key insight: <span class="fill-in">[Fill in after solving]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/last-stone-weight/">1046. Last Stone Weight</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Max-heap simulation]</span></li>
<li>Your solution time: <span class="fill-in">___</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/">1337. The K Weakest Rows in a Matrix</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Heap with custom comparator]</span></li>
<li>Your solution time: <span class="fill-in">___</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
</ul>
<p><strong>Medium (Complete 3-4):</strong></p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Min-heap approach]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Frequency + heap]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/k-closest-points-to-origin/">973. K Closest Points to Origin</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Max-heap of size K]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/find-median-from-data-stream/">295. Find Median from Data Stream</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Two heaps]</span></li>
<li>Difficulty: <span class="fill-in">[Rate 1-10]</span></li>
<li>Key insight: <span class="fill-in">[Fill in]</span></li>
</ul>
</li>
</ul>
<p><strong>Hard (Optional):</strong></p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Min-heap with K nodes]</span></li>
<li>Key insight: <span class="fill-in">[Fill in after solving]</span></li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <a href="https://leetcode.com/problems/sliding-window-median/">480. Sliding Window Median</a></p>
<ul>
<li>Pattern: <span class="fill-in">[Two heaps with removal]</span></li>
<li>Key insight: <span class="fill-in">[Fill in after solving]</span></li>
</ul>
</li>
</ul>
<hr/>
<h2 id="review-checklist">Review Checklist<a class="headerlink" href="#review-checklist" title="Permanent link">¶</a></h2>
<p>Before moving to the next topic:</p>
<ul class="task-list">
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Implementation</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Basic operations: Kth largest, K largest, heap sort all work</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Merge K: lists and arrays both work</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Top K: frequent elements and closest points work</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Two heaps: median finder works correctly</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> All client code runs successfully</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Pattern Recognition</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Can identify when to use min-heap vs max-heap</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understand when heap size should be K vs N</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Know when to use two heaps</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Recognize merge K sorted pattern</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Problem Solving</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Solved 3 easy problems</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Solved 3-4 medium problems</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Analyzed time/space complexity</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understood heap vs sort trade-offs</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Understanding</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Filled in all ELI5 explanations</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Built decision tree</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Identified when NOT to use heaps</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Can explain heap property and operations</li>
</ul>
</li>
<li class="task-list-item">
<p><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> <strong>Mastery Check</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could implement all patterns from memory</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could recognize pattern in new problem</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Could explain to someone else</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Understand PriorityQueue in Java</li>
</ul>
</li>
</ul>
<hr/>
<h3 id="mastery-certification">Mastery Certification<a class="headerlink" href="#mastery-certification" title="Permanent link">¶</a></h3>
<p><strong>I certify that I can:</strong></p>
<ul class="task-list">
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Implement all four heap patterns from memory</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Explain when to use min-heap vs max-heap</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Identify the correct pattern for new problems</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Analyze time and space complexity</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Compare trade-offs with alternative approaches</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Debug common heap mistakes (min/max confusion, indexing errors)</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Implement two-heap median finder</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Calculate parent/child indices correctly</li>
<li class="task-list-item"><label class="task-list-control"><input disabled="" type="checkbox"/><span class="task-list-indicator"></span></label> Teach this concept to someone else</li>
</ul></div>
</div>
<footer class="col-md-12 text-center">
<hr/>
<p>
<small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
</p>
</footer>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="../../js/bootstrap-3.0.3.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/java.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/languages/python.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>var base_url = "../.."</script>
<script src="../../js/base.js"></script>
<script src="../../search/main.js"></script>
<div aria-hidden="true" aria-labelledby="searchModalLabel" class="modal" id="mkdocs_search_modal" role="dialog" tabindex="-1">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<button class="close" data-dismiss="modal" type="button">
<span aria-hidden="true">×</span>
<span class="sr-only">Close</span>
</button>
<h4 class="modal-title" id="searchModalLabel">Search</h4>
</div>
<div class="modal-body">
<p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
<form>
<div class="form-group">
<input class="form-control" id="mkdocs-search-query" placeholder="Search..." title="Type search term here" type="text"/>
</div>
</form>
<div id="mkdocs-search-results"></div>
</div>
<div class="modal-footer">
</div>
</div>
</div>
</div><div aria-hidden="true" aria-labelledby="keyboardModalLabel" class="modal" id="mkdocs_keyboard_modal" role="dialog" tabindex="-1">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
<button class="close" data-dismiss="modal" type="button"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>
</div>
<div class="modal-body">
<table class="table">
<thead>
<tr>
<th style="width: 20%;">Keys</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="help shortcut"><kbd>?</kbd></td>
<td>Open this help</td>
</tr>
<tr>
<td class="next shortcut"><kbd>n</kbd></td>
<td>Next page</td>
</tr>
<tr>
<td class="prev shortcut"><kbd>p</kbd></td>
<td>Previous page</td>
</tr>
<tr>
<td class="search shortcut"><kbd>s</kbd></td>
<td>Search</td>
</tr>
</tbody>
</table>
</div>
<div class="modal-footer">
</div>
</div>
</div>
</div>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>
